<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>漫画ネームエディタ</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            height: 100vh; /* ビューポートの高さに合わせる */
            display: flex;
            flex-direction: column;
            background-color: #e0e0e0;
            overflow: hidden; /* 全体スクロールは禁止 (カラムスライドのため) */
            /* モバイルでフッターナビのスペースを確保 */
            padding-bottom: 0; /* PCデフォルト */
            transition: padding-bottom 0.3s ease-in-out;
        }

        /* PC版のデフォルトスタイル（4カラム表示） */
        .columns-wrapper { /* カラム全体を包むラッパー */
            flex-grow: 1;
            display: flex;
            width: 100%; /* PCでは100%幅 */
            padding-top: 0;
            padding-bottom: 0;
            box-sizing: border-box;
            overflow-x: auto; /* PCでは横スクロールを許可 */
            transition: none; /* PCではスライドアニメーションなし */
        }

        .column {
            width: 25vw; /* 各カラムの幅をビューポートの25%に */
            flex-shrink: 0; /* カラムが縮まないように */
            background-color: #fff;
            display: flex;
            flex-direction: column;
            border-right: 1px solid #eee; /* 各カラムの右側に境界線 */
            box-sizing: border-box;
            overflow: hidden; /* カラム自体はスクロールバーを持たない */
        }
        .column:last-child {
            border-right: none; /* 最後のカラムには境界線不要 */
        }


        /* 各カラムヘッダ内のボタンのスタイルを定義 */
        .column-header {
            background-color: #34495e;
            color: white;
            padding: 10px;
            font-weight: bold;
            text-align: center;
            flex-shrink: 0;
            position: sticky; /* カラム内でスクロールしても固定 */
            top: 0;
            z-index: 10;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .column-header .header-title {
            flex-shrink: 0;
            margin-right: auto;
        }

        .column-header .controls {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
            justify-content: flex-end;
            align-items: center;
        }

        .column-header .controls button {
            background-color: #6c757d;
            color: white;
            padding: 5px 10px;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 13px;
            transition: background-color 0.2s;
            margin-left: 5px;
        }

        .column-header .controls button#undoBtn,
        .column-header .controls button#redoBtn {
            background-color: #5a6268;
        }

        .column-header .controls button:hover {
            background-color: #5a6268;
        }
        
        .column-header .controls button#undoBtn:hover,
        .column-header .controls button#redoBtn:hover {
            background-color: #4a5157;
        }


        .column-header .controls button:disabled {
            background-color: #999;
            cursor: not-allowed;
        }

        .column-content {
            flex-grow: 1;
            overflow-y: auto; /* この領域でスクロールする */
            padding: 10px;
            flex-direction: column;
            gap: 10px;
        }

        textarea {
            width: 100%;
            height: auto; /* 自動リサイズのためにautoに */
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: 'Meiryo', 'Hiragino Kaku Gothic ProN', 'BIZ UDPGothic', sans-serif;
            font-size: 1em;
            line-height: 1.6;
            resize: none; /* デフォルトはなし */
            box-sizing: border-box;
            min-height: 50px;
            overflow: hidden; /* スクロールバーは表示しない */
        }

        .main-textarea {
            flex-grow: 1;
            min-height: 150px;
            resize: vertical; /* メインエディタもマニュアルリサイズ可能に */
        }

        .outline-textarea {
            min-height: 50px;
            max-height: none; 
            resize: vertical; 
        }

        .character-textarea { 
            min-height: 70vh; 
            max-height: none; 
            resize: vertical; 
            overflow-y: auto; 
        }
        
        /* シーン/ページ/セリフの動的表示用スタイル */
        .item-wrapper {
            display: flex;
            align-items: flex-start;
            padding: 2px 0;
            border-bottom: 1px dashed #eee;
            margin-bottom: 2px;
            font-family: 'Meiryo', 'Hiragino Kaku Gothic ProN', 'BIZ UDPGothic', sans-serif;
            font-size: 0.95em;
            line-height: 1.6;
            box-sizing: border-box;
            flex-shrink: 0;
            word-wrap: break-word;
            white-space: pre-wrap;
        }
        .item-wrapper textarea {
            flex-grow: 1;
            margin: 0;
            padding: 0;
            border: none;
            background: transparent;
            font-size: 1em;
            line-height: inherit;
            resize: none;
            overflow: hidden; /* スクロールバーは表示しない */
            height: auto;
            box-sizing: border-box;
        }

        /* シーンのtextarea */
        .scene-item-container textarea {
            width: 100%;
            border: 1px solid #ddd;
            border-top: none;
            padding: 5px;
            box-sizing: border-box;
            background-color: white;
            border-radius: 0;
            padding: 5px;
            overflow: hidden; 
            min-height: 40px; 
            max-height: none; 
            resize: none; 
            height: auto; 
        }
        
        /* ページとセリフのtextarea */
        .page-item-container textarea{
            width: 100%;
            border: 1px solid #ddd;
            padding: 5px;
            box-sizing: border-box;
            background-color: white;
            border-radius: 0;
            overflow: hidden; 
            min-height: 40px; 
            max-height: none; 
            resize: none; 
            height: auto; 
        }

        .item-wrapper .content-display {
            flex-grow: 1;
            margin: 0;
            padding: 0;
            border: none;
            background: transparent;
            font-size: 1em;
            line-height: inherit;
            white-space: pre-wrap;
            word-wrap: break-word;
            min-height: 1.6em;
        }

        /* シーンアイテムの具体的なスタイル */
        .scene-item-container {
            border: 1px solid #ccc;
            padding: 0px;
            margin-bottom: 10px;
            border-radius: 5px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
            display: flex;
            flex-direction: column;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        }
        /* アクティブな要素の強調表示 */
        .scene-item-container.active,
        .page-item-container.active,
        .dialogue-content.active,
        .character-item-container.active { 
            box-shadow: 0 0 8px 3px rgba(0, 123, 255, 0.5);
            border-color: #007bff;
            transform: scale(1.01);
        }

        .page-item-container {
            /* シーンと同じ色を適用するためのカスタムプロパティ */
            background-color: var(--scene-bg-color, #fff); /* デフォルトは白 */
            border: 1px solid #ccc; /* hikaku2.htmlに合わせて太めの枠線 */
            padding: 0px;
            margin: 0;
            margin-bottom: 5px;
            border-radius: 5px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
            cursor: pointer;
            transition: background-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        }
        
        /* シーンの背景色ローテーション用クラス - hikaku2.htmlに合わせる */
        .scene-color-0 { background-color: #fff; } /* シーン1は白 */
        .scene-color-1 { background-color: #e0f7fa; } /* シーン2は薄い水色 */
        .scene-color-2 { background-color: #f0f4c3; } /* シーン3は薄い黄色 */
        .scene-color-3 { background-color: #ffe0b2; } /* シーン4は薄いピンク */
        .scene-color-4 { background-color: #e1bee7; } /* シーン5は薄い紫 */

        /* セリフ表示部分のスタイル - hikaku2.htmlに忠実に */
        .dialogue-content {
            /* セリフの背景と枠線 */
            background-color: #fff3e0; /* 薄いオレンジ */
            border: 1px solid #ffcc80; /* 少し濃いオレンジの枠線 */
            padding: 5px; /* 内側の余白 */
            margin: 5px 0; /* 上下のマージン */
            border-radius: 3px; /* 角を少し丸く */
            box-sizing: border-box; /* paddingとborderを幅に含める */

            /* 左側の太いボーダー */
            border-left: 3px solid #ff9800; /* 濃いオレンジの左ボーダー */
            
            display: flex; /* セリフが複数行になっても表示できるように */
            align-items: flex-start; /* 上揃え */
            font-size: 0.95em;
            line-height: 1.6;
            white-space: pre-wrap; /* 改行を保持 */
            word-wrap: break-word; /* 長い単語の改行 */
        }
        .dialogue-content textarea {
            width: 100%;
            border: none; /* テキストエリアの枠線なし */
            padding: 0;
            margin: 0;
            background: transparent;
            font-size: inherit;
            line-height: inherit;
            resize: none;
            overflow: hidden;
            height: auto;
            min-height: 1.6em; /* 少なくとも1行分の高さ */
        }

        .scene-item-header, .page-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 10px; 
            flex-shrink: 0;
        }

        .scene-title-badge {
            background-color: #007bff;
            color: white;
            padding: 3px 8px;
            border-radius: 4px;
            font-weight: bold;
            font-size: 1.0em;
            display: inline-block;
        }

        .page-title-badge {
            background-color: #007bff;
            color: white;
            padding: 3px 8px;
            border-radius: 4px;
            font-weight: bold;
            font-size: 1.0em;
            display: inline-block;
        }

        .scene-item-header .delete-scene-btn, .page-item-header .delete-page-btn {
            background-color: #dc3545;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.8em;
            transition: background-color 0.2s;
        }

        .scene-item-header .delete-scene-btn:hover, .page-item-header .delete-page-btn:hover {
            background-color: #c82333;
        }

        .section-container {
            border: 1px solid #ccc;
            border-radius: 5px;
            margin-bottom: 10px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
            background-color: #f8f8f8;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .section-header {
            background-color: #f0f0f0;
            padding: 8px 10px;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: bold;
            flex-shrink: 0;
            cursor: pointer;
        }

        .section-header h3 {
            margin: 0;
            font-size: 1em;
            color: #333;
            flex-grow: 1;
        }

        .toggle-btn, .add-character-btn {
            background-color: #6c757d;
            color: white;
            padding: 4px 8px;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.8em;
            transition: background-color 0.2s;
            margin-left: 5px;
        }

        .toggle-btn:hover, .add-character-btn:hover {
            background-color: #5a6268;
        }

        .section-content {
            padding: 10px;
            transition: max-height 0.3s ease-out, opacity 0.3s ease-out, padding 0.3s ease-out;
            overflow-y: auto; 
            max-height: none; 
            opacity: 1;
            box-sizing: border-box;
        }

        .section-content.hidden {
            max-height: 0 !important;
            padding-top: 0;
            padding-bottom: 0;
            opacity: 0;
            visibility: hidden;
        }

        /* .character-textarea, .outline-textarea, .main-textarea は個別の max-height を持つ */
        .character-textarea, .outline-textarea, .main-textarea {
            border: none;
            min-height: 50px;
            background-color: white;
            border-radius: 0;
            padding: 5px;
        }

        .main-textarea {
            min-height: 150px;
        }

        /* 各シーンのページ追加ボタン */
        .add-page-btn {
            background-color: #607d8b; /* 暗い青緑系の色 (hikaku2.htmlのボタンに似た色) */
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.9em;
            margin: 5px 10px 10px auto; /* 上, 右, 下, 左: シーン説明の下、右寄せ */
            display: block; /* 独立したブロック要素に */
            transition: background-color 0.2s;
            align-self: flex-end; /* シーンアイテム内で右下に寄せる */
        }

        .add-page-btn:hover {
            background-color: #455a64; /* ホバーで少し暗く */
        }


        /* --- スマートフォン対応のためのメディアクエリ --- */
        @media (max-width: 768px) {
            body {
                overflow-y: hidden; 
                padding-bottom: 60px; 
            }

            .columns-wrapper {
                width: 400vw; 
                transform: translateX(0vw); 
                transition: transform 0.3s ease-in-out; 
                padding-top: 0; 
                padding-bottom: 0; 
                box-sizing: border-box;
                overflow-x: hidden; 
            }

            .column {
                width: 100vw; 
                border-right: none; 
            }

            .column-header {
                flex-direction: column;
                align-items: flex-start;
                padding: 8px;
            }

            .column-header .header-title {
                margin-right: 0;
                margin-bottom: 5px;
            }

            .column-header .controls {
                width: 100%;
                justify-content: space-around;
                gap: 5px;
            }

            .column-header .controls button {
                flex-grow: 1;
                margin-left: 0;
                padding: 8px 5px;
                font-size: 1em;
            }

            .column-content {
                padding: 8px;
            }

            .section-content {
                max-height: none; 
            }

            /* フッターナビゲーションのスタイル */
            .footer-nav {
                display: none; /* 初期は非表示に設定 */
                position: fixed;
                bottom: 0;
                left: 0;
                width: 100%;
                background-color: #34495e; 
                justify-content: space-around;
                padding: 10px 0;
                box-shadow: 0 -2px 5px rgba(0,0,0,0.1);
                z-index: 100;
            }

            .footer-nav button {
                background: none;
                border: none;
                color: white;
                font-size: 0.9em;
                padding: 10px 5px;
                cursor: pointer;
                flex-grow: 1;
                text-align: center;
                transition: background-color 0.2s;
            }

            .footer-nav button:hover {
                background-color: #5a6268;
            }

            .footer-nav button.active {
                background-color: #007bff; 
                font-weight: bold;
            }
        }

        @media (max-width: 480px) {
            .column-header .controls button {
                font-size: 0.9em;
                padding: 6px 3px;
            }

            .section-header h3 {
                font-size: 0.9em;
            }
            .toggle-btn, .add-character-btn {
                font-size: 0.7em;
                padding: 3px 6px;
            }
            
            textarea {
                font-size: 0.9em;
            }

            .section-content {
                max-height: none; 
            }

            .footer-nav button {
                font-size: 0.8em;
                padding: 8px 3px;
            }
        }
    </style>
</head>
<body>
    <div class="columns-wrapper" id="columnsWrapper">
        <div class="column main-column" data-column-id="main">
            <div class="column-header">
                <span class="header-title">メイン</span>
                <div class="controls">
                    <button id="newBtn">新規</button>
                    <button id="openBtn">開く</button>
                    <input type="file" id="fileInput" style="display: none;">
                    <button id="saveBtn">保存</button>
                    <button id="saveAsBtn">別名保存</button>
                    <button id="undoBtn">↶</button>
                    <button id="redoBtn">↷</button>
                </div>
            </div>
            <div class="column-content">
                <div class="section-container" id="outlineSection">
                    <div class="section-header">
                        <h3>アウトライン</h3>
                        <button class="toggle-btn" data-target="outlineContent">隠す</button>
                    </div>
                    <div class="section-content" id="outlineContent">
                        <textarea id="outlineEditor" class="outline-textarea" placeholder="ここに物語のアウトラインを記述してください。"></textarea>
                    </div>
                </div>
                
                <div class="section-container" id="characterSection">
                    <div class="section-header">
                        <h3>キャラクター</h3>
                        <div class="controls">
                            <button class="add-character-btn" id="addCharacterBtn">追加</button>
                            <button class="toggle-btn" data-target="characterContent">隠す</button>
                        </div>
                    </div>
                    <div class="section-content" id="characterContent">
                        <textarea id="characterEditor" class="character-textarea"></textarea>
                    </div>
                </div>

                <div class="section-container" id="mainEditorSection">
                    <div class="section-header">
                        <h3>ネーム本体 (XML)</h3>
                        <button class="toggle-btn" data-target="mainEditorContent">隠す</button>
                    </div>
                    <div class="section-content" id="mainEditorContent">
                        <textarea id="mainEditor" class="main-textarea" placeholder="XML形式でネームを記述してください。例：
<root><シーン><シーン説明>新しいシーン</シーン説明><ページ><ページ説明>新しいページ</ページ説明><セリフ>セリフA</セリフ></ページ></シーン></root>">
</textarea>
                    </div>
                </div>
            </div>
        </div>

        <div class="column scene-column" data-column-id="scene">
            <div class="column-header">
                <span class="header-title">シーン</span>
                <div class="controls">
                    <button id="addSceneBtn">シーン追加</button>
                </div>
            </div>
            <div class="column-content" id="sceneContent">
                <p>メインエディタの内容からシーンを抽出します。</p>
            </div>
        </div>

        <div class="column page-column" data-column-id="page">
            <div class="column-header">
                <span class="header-title">ページ</span>
            </div>
            <div class="column-content" id="pageContent">
                <p>メインエディタの内容からページを抽出します。</p>
            </div>
        </div>

        <div class="column serif-column" data-column-id="serif">
            <div class="column-header">
                <span class="header-title">セリフ</span>
                <div class="controls">
                    <button id="exportDialogueBtn">エクスポート</button>
                </div>
            </div>
            <div class="column-content" id="dialogueContent">
                <p>メインエディタの内容からセリフを抽出します。</p>
            </div>
        </div>
    </div>

    <footer class="footer-nav" id="footerNav">
        <button data-column-index="0">メイン</button>
        <button data-column-index="1">シーン</button>
        <button data-column-index="2">ページ</button>
        <button data-column-index="3">セリフ</button>
    </footer>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const outlineEditor = document.getElementById('outlineEditor');
            const characterEditor = document.getElementById('characterEditor');
            const mainEditor = document.getElementById('mainEditor');

            const sceneContentDiv = document.getElementById('sceneContent');
            const pageContentDiv = document.getElementById('pageContent');
            const dialogueContentDiv = document.getElementById('dialogueContent');

            const newBtn = document.getElementById('newBtn');
            const openBtn = document.getElementById('openBtn');
            const saveBtn = document.getElementById('saveBtn');
            const saveAsBtn = document.getElementById('saveAsBtn');
            const fileInput = document.getElementById('fileInput');
            const undoBtn = document.getElementById('undoBtn');
            const redoBtn = document.getElementById('redoBtn');

            const outlineContentDiv = document.getElementById('outlineContent');
            const characterContentDiv = document.getElementById('characterContent');
            const mainEditorContentDiv = document.getElementById('mainEditorContent');

            const toggleButtons = document.querySelectorAll('.toggle-btn');

            const addSceneBtn = document.getElementById('addSceneBtn'); 
            const addCharacterBtn = document.getElementById('addCharacterBtn');
            const exportDialogueBtn = document.getElementById('exportDialogueBtn');

            const columnsWrapper = document.getElementById('columnsWrapper');
            const footerNav = document.getElementById('footerNav'); 

            let currentFileName = '新規ネーム.txt';
            let history = [''];
            let historyIndex = 0;
            const MAX_HISTORY = 100;
            let updateTimeout;
            const DEBOUNCE_DELAY = 300; 
            let currentXmlDoc = null;
            let currentFileHandle = null;

            const xmlParser = new DOMParser();
            const xmlSerializer = new XMLSerializer(); 

            let nodeIdCounter = 0; 

            const sceneNodeIdToDomElementMap = new Map();
            const pageNodeIdToDomElementMap = new Map();
            const dialogueNodeIdToDomElementMap = new Map(); 

            let activeSceneElement = null;
            let activePageElement = null;
            let activeDialogueElement = null; 

            // --- カラム表示制御用の変数 ---             
            let currentColumnIndex = 0; 
            const columns = document.querySelectorAll('.column');
            let touchStartX = 0;
            let touchEndX = 0;

            function showColumn(index) {
                if (index < 0 || index >= columns.length) return;
                currentColumnIndex = index;

                document.querySelectorAll('.footer-nav button').forEach((btn, i) => {
                    if (i === currentColumnIndex) {
                        btn.classList.add('active');
                    } else {
                        btn.classList.remove('active');
                    }
                });

                if (window.innerWidth <= 768) {
                    columnsWrapper.style.transform = `translateX(-${index * 100}vw)`;
                    columnsWrapper.style.scrollBehavior = 'auto'; 
                    footerNav.style.display = 'flex'; 
                    document.body.style.paddingBottom = '60px'; 
                } else {
                    columnsWrapper.style.transform = `translateX(0)`; 
                    columnsWrapper.style.scrollBehavior = 'smooth'; 
                    columnsWrapper.scrollLeft = columns[index].offsetLeft;
                    footerNav.style.display = 'none'; 
                    document.body.style.paddingBottom = '0'; 
                }
            }

            function undo() {
                if (historyIndex > 0) {
                    historyIndex--;
                    mainEditor.value = history[historyIndex];
                    updateUIImmediate(); 
                }
            }

            function redo() {
                if (historyIndex < history.length - 1) {
                    historyIndex++;
                    mainEditor.value = history[historyIndex];
                    updateUIImmediate(); 
                }
            }

            function saveState() {
                const state = {
                    outlineContent: outlineEditor.value,
                    characterContent: characterEditor.value,
                    mainContent: mainEditor.value,
                    fileName: currentFileName,
                    history: history,
                    historyIndex: historyIndex,
                    outlineHidden: outlineContentDiv.classList.contains('hidden'),
                    characterHidden: characterContentDiv.classList.contains('hidden'),
                    mainEditorHidden: mainEditorContentDiv.classList.contains('hidden'),
                    currentColumnIndex: currentColumnIndex 
                };
                localStorage.setItem('comicNameEditorState', JSON.stringify(state));
                console.log('State saved.');
            }

            function clearAllEditors() {
                outlineEditor.value = '';
                characterEditor.value = `*主人公（名前：読み方、愛称）男女、歳
*関係性
*見た目、身体的特徴、服装
*性格・裏性格
*環境・生い立ち
――――――――――
*ヒロイン（名前：読み方、愛称）男女、歳
*関係性
*見た目、身体的特徴、服装
*性格・裏性格
*環境・生い立ち
――――――――――
*ライバル（名前：読み方、愛称）男女、歳
*関係性
*見た目、身体的特徴、服装
*性格・裏性格
*環境・生い立ち`;

                mainEditor.value = `<root><シーン><シーン説明>新しいシーン</シーン説明><ページ><ページ説明>新しいページの説明</ページ説明><セリフ>セリフ</セリフ></ページ></シーン></root>`; 
                currentFileName = '新規ネーム.txt';
                currentFileHandle = null;
                history = [mainEditor.value];
                historyIndex = 0;
                localStorage.removeItem('comicNameEditorState');
                
                setSectionVisibility(outlineContentDiv, false);
                setSectionVisibility(characterContentDiv, false);
                setSectionVisibility(mainEditorContentDiv, true);

                currentColumnIndex = 0; 
                showColumn(currentColumnIndex); 
                updateUIImmediate();
                alert('新しいネームを開始しました。');
            }


            function loadState() {
                const savedState = localStorage.getItem('comicNameEditorState');
                if (savedState) {
                    const state = JSON.parse(savedState);
                    outlineEditor.value = state.outlineContent || '';
                    characterEditor.value = state.characterContent || '';
                    mainEditor.value = state.mainContent || '';
                    currentFileName = state.fileName || '新規ネーム.txt';
                    history = state.history || [''];
                    historyIndex = state.historyIndex || 0;

                    setSectionVisibility(outlineContentDiv, state.outlineHidden || false);
                    setSectionVisibility(characterContentDiv, state.characterHidden || false);
                    setSectionVisibility(mainEditorContentDiv, state.mainEditorHidden || false);
                    
                    currentColumnIndex = state.currentColumnIndex !== undefined ? state.currentColumnIndex : 0; 
                    console.log('State loaded.');
                } else {
                    outlineEditor.value = '';
                    characterEditor.value = `*主人公（名前：読み方、愛称）男女、歳
*関係性
*見た目、身体的特徴、服装
*性格・裏性格
*環境・生い立ち
――――――――――
*ヒロイン（名前：読み方、愛称）男女、歳
*関係性
*見た目、身体的特徴、服装
*性格・裏性格
*環境・生い立ち
――――――――――
*ライバル（名前：読み方、愛称）男女、歳
*関係性
*見た目、身体的特徴、服装
*性格・裏性格
*環境・生い立ち`;

                    mainEditor.value = `<root><シーン><シーン説明>新しいシーン</シーン説明><ページ><ページ説明>新しいページの説明</ページ説明><セリフ>セリフ</セリフ></ページ></シーン></root>`; 
                    history = [mainEditor.value];
                    historyIndex = 0;

                    setSectionVisibility(outlineContentDiv, false);
                    setSectionVisibility(characterContentDiv, false);
                    setSectionVisibility(mainEditorContentDiv, true);
                    currentColumnIndex = 0; 
                }
                showColumn(currentColumnIndex); 
                updateUIImmediate();
            }

            function setSectionVisibility(contentDiv, isHidden) {
                const toggleBtn = contentDiv.previousElementSibling.querySelector('.toggle-btn');
                const addCharBtn = contentDiv.previousElementSibling.querySelector('.add-character-btn');
                if (isHidden) {
                    contentDiv.classList.add('hidden');
                    if (toggleBtn) toggleBtn.textContent = '開く';
                    if (addCharBtn) addCharBtn.style.display = 'none';
                } else {
                    contentDiv.classList.remove('hidden');
                    if (toggleBtn) toggleBtn.textContent = '隠す';
                    if (addCharBtn) addCharBtn.style.display = 'inline-block';
                }
                if (!isHidden && contentDiv.querySelector('textarea')) { 
                    autoResizeTextArea(contentDiv.querySelector('textarea'));
                }
            }

            function updateUI() {
                clearTimeout(updateTimeout);
                updateTimeout = setTimeout(() => {
                    updateUndoRedoButtons();
                    syncColumnsFromMainEditor();
                    setTimeout(autoResizeAllTextareas, 50); 
                    saveState();
                    console.log('UI updated and State saved (debounced).');
                }, DEBOUNCE_DELAY); // DEBOUNCE_DELAYを修正
            }

            function updateUIImmediate() {
                updateUndoRedoButtons();
                syncColumnsFromMainEditor();
                setTimeout(autoResizeAllTextareas, 50); 
                saveState();
                console.log('UI updated and State saved (immediate).');
            }

            function updateUndoRedoButtons() {
                undoBtn.disabled = historyIndex === 0;
                redoBtn.disabled = historyIndex === history.length - 1;
            }

            function addToHistory(content) {
                if (history.length > 0 && history[historyIndex] === content) {
                    return;
                }
                if (historyIndex < history.length - 1) {
                    history = history.slice(0, historyIndex + 1);
                }
                history.push(content);
                if (history.length > MAX_HISTORY) {
                    history.shift();
                }
                historyIndex = history.length - 1; 
                updateUndoRedoButtons();
            }

            openBtn.addEventListener('click', async () => {
                try {
                    const [fileHandle] = await window.showOpenFilePicker({
                        types: [
                            {
                                description: 'Text Files',
                                accept: {
                                    'text/plain': ['.txt', '.xml'], 
                                },
                            },
                        ],
                    });
                    const file = await fileHandle.getFile();
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        const content = event.target.result;
                        try {
                            const parser = new DOMParser();
                            const xmlDoc = parser.parseFromString(content, "text/xml");
                            currentXmlDoc = xmlDoc; 

                            const errorNode = xmlDoc.querySelector('parsererror');
                            // XML parsing error または root要素が見つからない場合、あるいはファイル内容が空の場合
                            if (errorNode || !xmlDoc.documentElement || xmlDoc.documentElement.nodeName !== 'root' || content.trim() === '') {
                                alert('ファイルの解析中にエラーが発生しました、またはファイルが空です。有効なXML形式でファイルを保存してください。');
                                console.error('XML parsing error:', errorNode ? errorNode.textContent : 'Invalid root element or empty file content');
                                mainEditor.value = `<root/>`; // 有効な空のXMLを設定
                            } else {
                                const outlineElement = xmlDoc.querySelector('outline');
                                outlineEditor.value = outlineElement ? outlineElement.textContent : '';

                                const characterElement = xmlDoc.querySelector('character');
                                characterEditor.value = characterElement ? characterElement.textContent : '';
                                
                                mainEditor.value = xmlSerializer.serializeToString(currentXmlDoc.documentElement);
                            }

                            currentFileName = file.name;
                            currentFileHandle = fileHandle; 
                            history = [mainEditor.value];
                            historyIndex = 0;
                            updateUIImmediate();
                            alert(`ファイル「${currentFileName}」を開きました。`);

                        } catch (e) {
                            alert('ファイルの読み込み中にエラーが発生しました。ファイルが破損しているか、不正な形式です。');
                            console.error('File parsing error:', e);
                            mainEditor.value = `<root/>`; // エラー時も有効な空のXMLを設定
                            updateUIImmediate(); // デフォルトでUIを更新
                        }
                    };
                    reader.readAsText(file);
                } catch (error) {
                    if (error.name === 'AbortError') {
                        console.log('ファイル選択がキャンセルされました。');
                    } else {
                        console.error('ファイルを開く際にエラーが発生しました:', error);
                        alert('ファイルを開く際にエラーが発生しました。');
                    }
                }
            });

            saveBtn.addEventListener('click', async () => {
                if (currentFileHandle) {
                    await writeFile(currentFileHandle, mainEditor.value);
                    alert('ファイルを上書き保存しました。');
                } else {
                    saveAsBtn.click(); 
                }
            });

            saveAsBtn.addEventListener('click', async () => {
                try {
                    const suggestedName = currentFileName.endsWith('.txt') ? currentFileName : currentFileName + '.txt';
                    const fileHandle = await window.showSaveFilePicker({
                        suggestedName: suggestedName,
                        types: [
                            {
                                description: 'Text Files',
                                accept: {
                                    'text/plain': ['.txt'],
                                },
                            },
                            {
                                description: 'XML Files',
                                accept: {
                                    'application/xml': ['.xml'],
                                },
                            },
                        ],
                    });
                    await writeFile(fileHandle, mainEditor.value);
                    currentFileHandle = fileHandle;
                    currentFileName = fileHandle.name;
                    alert(`ファイル「${currentFileName}」を保存しました。`);
                } catch (error) {
                    if (error.name === 'AbortError') {
                        console.log('ファイル保存がキャンセルされました。');
                    } else {
                        console.error('ファイルを保存する際にエラーが発生しました:', error);
                        alert('ファイルを保存する際にエラーが発生しました。');
                    }
                }
            });

            async function writeFile(fileHandle, contents) {
                const writable = await fileHandle.createWritable();
                await writable.write(contents);
                await writable.close();
            }
            
            newBtn.addEventListener('click', clearAllEditors);
            undoBtn.addEventListener('click', undo);
            redoBtn.addEventListener('click', redo);

            mainEditor.addEventListener('input', () => {
                addToHistory(mainEditor.value);
                updateUI(); 
            });

            outlineEditor.addEventListener('input', updateUI);
            characterEditor.addEventListener('input', updateUI);


            function autoResizeTextArea(textarea) {
                if (textarea) { 
                    textarea.style.height = 'auto'; 
                    textarea.style.height = textarea.scrollHeight + 'px'; 
                }
            }

            function autoResizeAllTextareas() {
                document.querySelectorAll('textarea').forEach(autoResizeTextArea);
            }

            toggleButtons.forEach(button => {
                button.addEventListener('click', (event) => {
                    const targetId = button.dataset.target;
                    const targetContent = document.getElementById(targetId);
                    const isHidden = targetContent.classList.contains('hidden');
                    setSectionVisibility(targetContent, !isHidden);
                    saveState(); 
                });
            });

            addCharacterBtn.addEventListener('click', () => {
                const newCharacterText = `
――――――――――
*新キャラクター（名前：読み方、愛称）男女、歳
*関係性
*見た目、身体的特徴、服装
*性格・裏性格
*環境・生い立ち`;
                characterEditor.value += newCharacterText;
                autoResizeTextArea(characterEditor);
                updateUI();
            });

            function syncColumnsFromMainEditor() {
                const xmlString = mainEditor.value;
                try {
                    const parser = new DOMParser();
                    const xmlDoc = parser.parseFromString(xmlString, "text/xml");
                    currentXmlDoc = xmlDoc; 

                    const errorNode = xmlDoc.querySelector('parsererror');
                    if (errorNode) {
                        sceneContentDiv.innerHTML = `<p style="color: red;">XMLエラー: ${errorNode.textContent}</p>`;
                        pageContentDiv.innerHTML = `<p style="color: red;">XMLエラー: ${errorNode.textContent}</p>`;
                        dialogueContentDiv.innerHTML = `<p style="color: red;">XMLエラー: ${errorNode.textContent}</p>`;
                        return;
                    }

                    if (!xmlDoc.documentElement || xmlDoc.documentElement.nodeName !== 'root') {
                        sceneContentDiv.innerHTML = `<p style="color: red;">XMLファイルに&lt;root&gt;要素が見つかりません。</p>`;
                        pageContentDiv.innerHTML = `<p style="color: red;">XMLファイルに&lt;root&gt;要素が見つかりません。</p>`;
                        dialogueContentDiv.innerHTML = `<p style="color: red;">XMLファイルに&lt;root&gt;要素が見つかりません。</p>`;
                        return;
                    }

                    renderSceneColumn(xmlDoc);
                    renderPageColumn(xmlDoc);
                    renderDialogueColumn(xmlDoc);

                } catch (e) {
                    sceneContentDiv.innerHTML = `<p style="color: red;">XML解析エラー: ${e.message}</p>`;
                    pageContentDiv.innerHTML = `<p style="color: red;">XML解析エラー: ${e.message}</p>`;
                    dialogueContentDiv.innerHTML = `<p style="color: red;">XML解析エラー: ${e.message}</p>`;
                    console.error("XML parse error:", e);
                }
            }

            // --- シーンカラムのレンダリング ---
            function renderSceneColumn(xmlDoc) {
                sceneContentDiv.innerHTML = ''; 
                const scenes = xmlDoc.querySelectorAll('root > シーン');
                // hikaku2.htmlのシーンカラーを正確に再現
                const sceneColors = ['#fff', '#e0f7fa', '#f0f4c3', '#ffe0b2', '#e1bee7'];

                if (scenes.length === 0) {
                    sceneContentDiv.innerHTML = '<p>シーンがありません。<br>「シーン追加」ボタンで追加できます。</p>';
                    return;
                }

                scenes.forEach((sceneNode, sceneIndex) => {
                    if (!sceneNode.hasAttribute('data-node-id')) {
                        sceneNode.setAttribute('data-node-id', `s-${nodeIdCounter++}`);
                    }
                    const sceneNodeId = sceneNode.getAttribute('data-node-id');

                    const sceneDiv = document.createElement('div');
                    sceneDiv.classList.add('scene-item-container');
                    sceneDiv.setAttribute('data-scene-node-id', sceneNodeId); 
                    // シーンの色を直接スタイルに適用
                    const bgColor = sceneColors[sceneIndex % sceneColors.length];
                    sceneDiv.style.backgroundColor = bgColor;
                    // ページに色を伝えるためのカスタムプロパティを設定
                    sceneDiv.style.setProperty('--scene-bg-color', bgColor);

                    const sceneHeader = document.createElement('div');
                    sceneHeader.classList.add('scene-item-header');

                    const sceneTitleBadge = document.createElement('span');
                    sceneTitleBadge.classList.add('scene-title-badge');
                    sceneTitleBadge.textContent = `シーン ${sceneIndex + 1}`;
                    sceneHeader.appendChild(sceneTitleBadge);

                    const deleteSceneBtn = document.createElement('button');
                    deleteSceneBtn.classList.add('delete-scene-btn');
                    deleteSceneBtn.textContent = '削除';
                    deleteSceneBtn.addEventListener('click', (event) => {
                        event.stopPropagation(); 
                        if (confirm(`シーン ${sceneIndex + 1} を削除しますか？`)) {
                            sceneNode.remove(); 
                            mainEditor.value = xmlSerializer.serializeToString(xmlDoc.documentElement);
                            addToHistory(mainEditor.value); 
                            updateUIImmediate(); 
                        }
                    });
                    sceneHeader.appendChild(deleteSceneBtn);
                    sceneDiv.appendChild(sceneHeader);

                    const sceneDescNode = sceneNode.querySelector('シーン説明');
                    const sceneDescTextarea = document.createElement('textarea');
                    sceneDescTextarea.classList.add('scene-item-textarea');
                    sceneDescTextarea.placeholder = 'ここにシーンの説明を記述';
                    sceneDescTextarea.value = sceneDescNode ? sceneDescNode.textContent : '';
                    sceneDescTextarea.addEventListener('input', (event) => {
                        if (sceneDescNode) {
                            sceneDescNode.textContent = event.target.value;
                        } else {
                            const newSceneDesc = xmlDoc.createElement('シーン説明');
                            newSceneDesc.textContent = event.target.value;
                            sceneNode.insertBefore(newSceneDesc, sceneNode.firstChild);
                        }
                        mainEditor.value = xmlSerializer.serializeToString(xmlDoc.documentElement);
                        addToHistory(mainEditor.value);
                        autoResizeTextArea(event.target);
                    });
                    sceneDescTextarea.addEventListener('focus', () => {
                        setActiveElement(sceneDiv, null, null); 
                    });
                    sceneDiv.appendChild(sceneDescTextarea);

                    sceneContentDiv.appendChild(sceneDiv);
                    sceneNodeIdToDomElementMap.set(sceneNodeId, sceneDiv); 
                });

                restoreActiveElement();
                setTimeout(autoResizeAllTextareas, 100); 
            }

            // --- ページカラムのレンダリング ---
            function renderPageColumn(xmlDoc) {
                pageContentDiv.innerHTML = ''; 
                // シーンごとのページとボタンを管理するため、シーンのDOM要素を取得
                const scenesInDom = document.querySelectorAll('.scene-item-container');

                if (scenesInDom.length === 0) {
                    pageContentDiv.innerHTML = '<p>ページがありません。<br>シーンカラムから追加できます。</p>';
                    return;
                }

                scenesInDom.forEach(sceneDomEl => {
                    const sceneNodeId = sceneDomEl.getAttribute('data-scene-node-id');
                    const sceneNode = currentXmlDoc.querySelector(`[data-node-id="${sceneNodeId}"]`);
                    
                    if (!sceneNode) return;

                    const pages = sceneNode.querySelectorAll('ページ');
                    
                    pages.forEach((pageNode, pageIndex) => {
                        if (!pageNode.hasAttribute('data-node-id')) {
                            pageNode.setAttribute('data-node-id', `p-${nodeIdCounter++}`);
                        }
                        const pageNodeId = pageNode.getAttribute('data-node-id');
                        
                        const pageDiv = document.createElement('div');
                        pageDiv.classList.add('page-item-container');
                        pageDiv.setAttribute('data-page-node-id', pageNodeId);
                        pageDiv.setAttribute('data-scene-node-id', sceneNodeId); // 親シーンのIDも保持

                        // 親シーンの背景色を取得してページに適用
                        const sceneBgColor = window.getComputedStyle(sceneDomEl).backgroundColor;
                        pageDiv.style.backgroundColor = sceneBgColor;

                        const pageHeader = document.createElement('div');
                        pageHeader.classList.add('page-item-header');

                        const pageTitleBadge = document.createElement('span');
                        pageTitleBadge.classList.add('page-title-badge');
                        pageTitleBadge.textContent = `ページ ${pageIndex + 1}`; // 「ページ 1」形式に修正
                        pageHeader.appendChild(pageTitleBadge);

                        const deletePageBtn = document.createElement('button');
                        deletePageBtn.classList.add('delete-page-btn');
                        deletePageBtn.textContent = '削除';
                        deletePageBtn.addEventListener('click', (event) => {
                            event.stopPropagation();
                            if (confirm(`ページ ${pageIndex + 1} を削除しますか？`)) {
                                pageNode.remove();
                                mainEditor.value = xmlSerializer.serializeToString(xmlDoc.documentElement);
                                addToHistory(mainEditor.value);
                                updateUIImmediate();
                            }
                        });
                        pageHeader.appendChild(deletePageBtn);
                        pageDiv.appendChild(pageHeader);

                        const pageDescNode = pageNode.querySelector('ページ説明');
                        const pageDescTextarea = document.createElement('textarea');
                        pageDescTextarea.classList.add('page-item-textarea');
                        pageDescTextarea.placeholder = 'ここにページの説明を記述';
                        pageDescTextarea.value = pageDescNode ? pageDescNode.textContent : '';
                        pageDescTextarea.addEventListener('input', (event) => {
                            if (pageDescNode) {
                                pageDescNode.textContent = event.target.value;
                            } else {
                                const newPageDesc = xmlDoc.createElement('ページ説明');
                                newPageDesc.textContent = event.target.value;
                                pageNode.insertBefore(newPageDesc, pageNode.firstChild);
                            }
                            mainEditor.value = xmlSerializer.serializeToString(xmlDoc.documentElement);
                            addToHistory(mainEditor.value);
                            autoResizeTextArea(event.target);
                        });
                        pageDescTextarea.addEventListener('focus', () => {
                            setActiveElement(
                                sceneNodeIdToDomElementMap.get(sceneNode.getAttribute('data-node-id')),
                                pageDiv,
                                null
                            );
                        });
                        pageDiv.appendChild(pageDescTextarea);

                        pageContentDiv.appendChild(pageDiv);
                        pageNodeIdToDomElementMap.set(pageNodeId, pageDiv); 
                    });

                    // 各シーンに内包されるページが全てレンダリングされた後、
                    // そのシーンに対応するDOM要素の一番最後に「このシーンにページを追加」ボタンを追加
                    // NOTE: このボタンはページカラムに移動
                    const addPageBtn = document.createElement('button');
                    addPageBtn.classList.add('add-page-btn');
                    addPageBtn.textContent = `シーン ${sceneIndex + 1} にページを追加`; // シーン番号を明記
                    addPageBtn.setAttribute('data-target-scene-node-id', sceneNodeId); // どのシーンに紐づくか
                    addPageBtn.addEventListener('click', (event) => {
                        event.stopPropagation(); 

                        const targetSceneNodeId = event.target.getAttribute('data-target-scene-node-id');
                        const targetSceneNode = currentXmlDoc.querySelector(`[data-node-id="${targetSceneNodeId}"]`);

                        if (!targetSceneNode) {
                            console.error('Target scene node not found for adding page.');
                            return;
                        }

                        const newPage = xmlDoc.createElement('ページ');
                        const newPageDesc = xmlDoc.createElement('ページ説明');
                        newPageDesc.textContent = '新しいページの説明';
                        newPage.appendChild(newPageDesc);
                        
                        const newDialogue = xmlDoc.createElement('セリフ');
                        newDialogue.textContent = 'セリフ'; // デフォルトのセリフ形式に合わせる
                        newPage.appendChild(newDialogue);

                        targetSceneNode.appendChild(newPage); 

                        mainEditor.value = xmlSerializer.serializeToString(xmlDoc.documentElement);
                        addToHistory(mainEditor.value);
                        updateUIImmediate();
                    });
                    // シーンの各ページの後にボタンを追加するが、
                    // シーン内のすべてのページがレンダリングされた後にまとめて追加
                    pageContentDiv.appendChild(addPageBtn);
                });

                restoreActiveElement();
                setTimeout(autoResizeAllTextareas, 100);
            }

            // --- セリフカラムのレンダリング ---
            function renderDialogueColumn(xmlDoc) {
                dialogueContentDiv.innerHTML = ''; 

                const scenes = xmlDoc.querySelectorAll('root > シーン');

                if (scenes.length === 0) {
                    dialogueContentDiv.innerHTML = '<p>セリフがありません。<br>メインエディタから追加できます。</p>';
                    return;
                }

                scenes.forEach((sceneNode, sceneIndex) => {
                    const pagesInScene = sceneNode.querySelectorAll('ページ');
                    pagesInScene.forEach((pageNode, pageIndex) => {
                        const dialogues = pageNode.querySelectorAll('セリフ');
                        
                            dialogues.forEach((dialogueNode, dialogueIndex) => {
                                if (!dialogueNode.hasAttribute('data-node-id')) {
                                    dialogueNode.setAttribute('data-node-id', `d-${nodeIdCounter++}`);
                                }
                                const dialogueNodeId = dialogueNode.getAttribute('data-node-id');

                                const dialogueDiv = document.createElement('div');
                                dialogueDiv.classList.add('dialogue-content');
                                dialogueDiv.setAttribute('data-dialogue-node-id', dialogueNodeId);
                                dialogueDiv.setAttribute('data-scene-node-id', sceneNode.getAttribute('data-node-id'));
                                dialogueDiv.setAttribute('data-page-node-id', pageNode.getAttribute('data-node-id'));

                                // セリフ内容全体をtextareaに入れる
                                const dialogueTextarea = document.createElement('textarea');
                                dialogueTextarea.value = dialogueNode.textContent; // XMLノードのテキスト内容全体をセット
                                dialogueTextarea.placeholder = 'セリフを入力'; // 「キャラクター名: 」のプレースホルダーを削除

                                dialogueTextarea.addEventListener('input', (event) => {
                                    dialogueNode.textContent = event.target.value; // textareaの値をそのままXMLノードに保存
                                    mainEditor.value = xmlSerializer.serializeToString(xmlDoc.documentElement);
                                    addToHistory(mainEditor.value);
                                    autoResizeTextArea(event.target);
                                });
                                dialogueTextarea.addEventListener('focus', () => {
                                    setActiveElement(
                                        sceneNodeIdToDomElementMap.get(sceneNode.getAttribute('data-node-id')),
                                        pageNodeIdToDomElementMap.get(pageNode.getAttribute('data-node-id')),
                                        dialogueDiv
                                    );
                                });

                                dialogueDiv.appendChild(dialogueTextarea);

                                dialogueContentDiv.appendChild(dialogueDiv); 
                                dialogueNodeIdToDomElementMap.set(dialogueNodeId, dialogueDiv); 
                            });
                    });
                });
                restoreActiveElement();
                setTimeout(autoResizeAllTextareas, 100);
            }

            function setActiveElement(sceneEl, pageEl, dialogueEl) {
                document.querySelectorAll('.active').forEach(el => el.classList.remove('active'));

                if (sceneEl) {
                    sceneEl.classList.add('active');
                    if (window.innerWidth <= 768) {
                        showColumn(1); 
                    } else {
                        sceneEl.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                    }
                }
                if (pageEl) {
                    pageEl.classList.add('active');
                    if (window.innerWidth <= 768) {
                        showColumn(2); 
                    } else {
                        pageEl.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                    }
                }
                if (dialogueEl) {
                    dialogueEl.classList.add('active');
                    if (window.innerWidth <= 768) {
                        showColumn(3); 
                    } else {
                        dialogueEl.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                    }
                }

                activeSceneElement = sceneEl;
                activePageElement = pageEl;
                activeDialogueElement = dialogueEl;
            }

            function restoreActiveElement() {
                if (activeSceneElement && document.body.contains(activeSceneElement)) {
                    activeSceneElement.classList.add('active');
                } else {
                    activeSceneElement = null;
                }
                if (activePageElement && document.body.contains(activePageElement)) {
                    activePageElement.classList.add('active');
                } else {
                    activePageElement = null;
                }
                if (activeDialogueElement && document.body.contains(activeDialogueElement)) {
                    activeDialogueElement.classList.add('active');
                } else {
                    activeDialogueElement = null;
                }
            }

            addSceneBtn.addEventListener('click', () => {
                if (!currentXmlDoc || !currentXmlDoc.documentElement || currentXmlDoc.documentElement.nodeName !== 'root') {
                    currentXmlDoc = document.implementation.createDocument(null, 'root', null); 
                }

                const newScene = currentXmlDoc.createElement('シーン');
                const newSceneDesc = currentXmlDoc.createElement('シーン説明');
                newSceneDesc.textContent = '新しいシーンの説明';
                newScene.appendChild(newSceneDesc);

                const newPage = currentXmlDoc.createElement('ページ');
                const newPageDesc = currentXmlDoc.createElement('ページ説明');
                newPageDesc.textContent = '新しいページの説明';
                newPage.appendChild(newPageDesc);
                
                const newDialogue = currentXmlDoc.createElement('セリフ');
                newDialogue.textContent = 'セリフ'; // デフォルトのセリフ形式に合わせる
                newPage.appendChild(newDialogue); 
                
                newScene.appendChild(newPage); 

                currentXmlDoc.documentElement.appendChild(newScene); 

                mainEditor.value = xmlSerializer.serializeToString(currentXmlDoc.documentElement);
                addToHistory(mainEditor.value);
                updateUIImmediate();
            });


            exportDialogueBtn.addEventListener('click', () => {
                let textContent = '';
                const scenes = currentXmlDoc.querySelectorAll('root > シーン');
                
                scenes.forEach((sceneNode, sceneIndex) => {
                    const sceneDescNode = sceneNode.querySelector('シーン説明');
                    const sceneDesc = sceneDescNode ? sceneDescNode.textContent : `シーン ${sceneIndex + 1} (説明なし)`;
                    textContent += `## シーン ${sceneIndex + 1}: ${sceneDesc}\n\n`;

                    const pagesInScene = sceneNode.querySelectorAll('ページ');
                    pagesInScene.forEach((pageNode, pageIndex) => {
                        const pageDescNode = pageNode.querySelector('ページ説明');
                        const pageDesc = pageDescNode ? pageDescNode.textContent : `ページ ${pageIndex + 1} (説明なし)`;
                        textContent += `### ページ ${pageIndex + 1}: ${pageDesc}\n`; // 「ページ 1」形式に合わせる

                        const dialogues = pageNode.querySelectorAll('セリフ');
                        if (dialogues.length > 0) {
                            dialogues.forEach((dialogueNode) => { // dialogueIndex は不要
                                textContent += `- ${dialogueNode.textContent}\n`; // セリフ内容をそのまま出力
                            });
                        } else {
                            textContent += `- (セリフなし)\n`;
                        }
                        textContent += '\n'; 
                    });
                    textContent += '\n'; 
                });

                const blob = new Blob([textContent], { type: 'text/plain;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'セリフ一覧.txt';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            });


            loadState();

            mainEditor.addEventListener('dragover', (event) => {
                event.preventDefault();
                event.stopPropagation();
                mainEditor.classList.add('drag-over');
                document.body.classList.add('drag-over'); 
            });

            mainEditor.addEventListener('dragleave', (event) => {
                event.preventDefault();
                event.stopPropagation();
                mainEditor.classList.remove('drag-over');
                document.body.classList.remove('drag-over');
            });

            mainEditor.addEventListener('drop', (event) => {
                event.preventDefault();
                event.stopPropagation();
                mainEditor.classList.remove('drag-over');
                document.body.classList.remove('drag-over');

                const files = event.dataTransfer.files;
                if (files.length > 0) {
                    const file = files[0];
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const content = e.target.result;
                        try {
                            const parser = new DOMParser();
                            const xmlDoc = parser.parseFromString(content, "text/xml");
                            currentXmlDoc = xmlDoc;

                            const errorNode = xmlDoc.querySelector('parsererror');
                            if (errorNode || !xmlDoc.documentElement || xmlDoc.documentElement.nodeName !== 'root' || content.trim() === '') {
                                alert('ドロップされたファイルの解析中にエラーが発生しました、またはファイルが空です。有効なXML形式でファイルを保存してください。');
                                console.error('XML parsing error (drag & drop):', errorNode ? errorNode.textContent : 'Invalid root element or empty file content');
                                mainEditor.value = `<root/>`; 
                            } else {
                                const outlineElement = xmlDoc.querySelector('outline');
                                outlineEditor.value = outlineElement ? outlineElement.textContent : '';

                                const characterElement = xmlDoc.querySelector('character');
                                characterEditor.value = characterElement ? characterElement.textContent : '';

                                mainEditor.value = xmlSerializer.serializeToString(currentXmlDoc.documentElement);
                            }

                            currentFileName = file.name;
                            currentFileHandle = file.getFileSystemHandle(); 
                            history = [mainEditor.value];
                            historyIndex = 0;
                            updateUIImmediate();
                            alert(`ファイル「${currentFileName}」を読み込みました。`);

                        } catch (parseError) {
                            alert('ドロップされたファイルの読み込み中にエラーが発生しました。');
                            console.error('Dropped file parsing error:', parseError);
                            mainEditor.value = `<root/>`;
                            updateUIImmediate();
                        }
                    };
                    reader.readAsText(file);
                }
            });

            document.body.addEventListener('dragover', (event) => {
                event.preventDefault();
                event.stopPropagation();
            });
            document.body.addEventListener('drop', (event) => {
                event.preventDefault();
                event.stopPropagation();
            });


            // スワイプ操作によるカラム移動 (モバイルのみ)
            columnsWrapper.addEventListener('touchstart', (e) => {
                if (window.innerWidth <= 768) {
                    touchStartX = e.changedTouches[0].screenX;
                    columnsWrapper.style.transition = 'none'; 
                }
            }, { passive: false }); 

            columnsWrapper.addEventListener('touchmove', (e) => {
                if (window.innerWidth <= 768) {
                    touchEndX = e.changedTouches[0].screenX;
                    const diff = touchStartX - touchEndX; 
                    const currentTranslate = -currentColumnIndex * window.innerWidth;
                    const newTransform = (currentTranslate - diff) / window.innerWidth; 
                    columnsWrapper.style.transform = `translateX(${newTransform}vw)`;
                }
            }, { passive: false });

            columnsWrapper.addEventListener('touchend', (e) => { 
                if (window.innerWidth <= 768) {
                    const diff = touchEndX - touchStartX;
                    const swipeThreshold = window.innerWidth * 0.15; 

                    let newColumnIndex = currentColumnIndex;
                    if (diff < -swipeThreshold) { 
                        newColumnIndex = Math.min(columns.length - 1, currentColumnIndex + 1);
                    } else if (diff > swipeThreshold) { 
                        newColumnIndex = Math.max(0, currentColumnIndex - 1);
                    } else {
                        newColumnIndex = currentColumnIndex;
                    }
                    
                    columnsWrapper.style.transition = 'transform 0.3s ease-out'; 
                    showColumn(newColumnIndex); 
                }
            }, { passive: false }); 

            document.querySelectorAll('.footer-nav button').forEach(button => {
                button.addEventListener('click', (event) => {
                    const index = parseInt(event.target.dataset.columnIndex, 10);
                    showColumn(index);
                });
            });

            window.addEventListener('resize', () => {
                showColumn(currentColumnIndex); 
                autoResizeAllTextareas(); 
                if (window.innerWidth > 768) {
                    footerNav.style.display = 'none';
                    document.body.style.paddingBottom = '0';
                } else {
                    footerNav.style.display = 'flex';
                    document.body.style.paddingBottom = '60px'; 
                }
            });

            // 初期ロード時のカラム表示とフッターナビの制御
            if (window.innerWidth <= 768) {
                footerNav.style.display = 'flex';
                document.body.style.paddingBottom = '60px';
            } else {
                footerNav.style.display = 'none';
                document.body.style.paddingBottom = '0';
            }
        });
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="ja">
<head>
    <!-- <head>タグ内に追加 -->
    <!-- <head>タグ内に追加 -->
    <link rel="manifest" href="./manifest.json">
    <link rel="apple-touch-icon" href="./icon192.png">
    <!-- iOS用の複数サイズ対応 -->
    <link rel="apple-touch-icon" sizes="180x180" href="./icon180.png">
    <link rel="apple-touch-icon" sizes="152x152" href="./icon152.png">
    <link rel="apple-touch-icon" sizes="120x120" href="./icon120.png">
        <!-- ファビコン -->
    <link rel="icon" type="image/png" sizes="32x32" href="./icon32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="./icon16.png">
    <meta charset="UTF-8">
    <!--<meta name="viewport" content="width=device-width, initial-scale=1.0"> -->
    
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>漫画ネームエディタhikaku2</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            height: 100vh; /* ビューポートの高さに合わせる */
            display: flex;
            flex-direction: column;
            background-color: #e0e0e0;
            overflow: hidden; /* 全体スクロールは禁止 (カラムスライドのため) */

            touch-action: pan-y;
        }

        /* PC版のデフォルトスタイル（4カラム表示） */
        .columns-wrapper { /* カラム全体を包むラッパー */
            flex-grow: 1;
            display: flex;
            width: 100%; /* PCでは100%幅 */
            padding-top: 0; /* グローバルヘッダーを削除したので0 */
            padding-bottom: 0; /* フッターナビを削除したので0 */
            box-sizing: border-box;
            overflow-x: auto; /* PCでは横スクロールを許可 */
            transition: none; /* PCではスライドアニメーションなし */
        }

        .column {
            width: 25vw; /* 各カラムの幅をビューポートの25%に */
            flex-shrink: 0; /* カラムが縮まないように */
            background-color: #fff;
            display: flex;
            flex-direction: column;
            border-right: 1px solid #eee; /* 各カラムの右側に境界線 */
            box-sizing: border-box;
            overflow: hidden; /* カラム自体はスクロールバーを持たない */
        }
        .column:last-child {
            border-right: none; /* 最後のカラムには境界線不要 */
        }


        /* 各カラムヘッダ内のボタンのスタイルを定義 */
        .column-header {
            background-color: #34495e;
            color: white;
            padding: 10px;
            font-weight: bold;
            text-align: center;
            flex-shrink: 0;
            position: sticky; /* カラム内でスクロールしても固定 */
            top: 0;
            z-index: 10;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .column-header .header-title {
            flex-shrink: 0;
            margin-right: auto;
        }

        .column-header .controls {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
            justify-content: flex-end;
            align-items: center;
        }

        .column-header .controls button {
            background-color: #6c757d;
            color: white;
            padding: 5px 10px;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 13px;
            transition: background-color 0.2s;
            margin-left: 5px;
        }

        .column-header .controls button#undoBtn,
        .column-header .controls button#redoBtn {
            background-color: #5a6268;
        }

        .column-header .controls button:hover {
            background-color: #5a6268;
        }
        
        .column-header .controls button#undoBtn:hover,
        .column-header .controls button#redoBtn:hover {
            background-color: #4a5157;
        }


        .column-header .controls button:disabled {
            background-color: #999;
            cursor: not-allowed;
        }

        .column-content {
            flex-grow: 1;
            overflow-y: auto; /* この領域でスクロールする */
            padding: 10px;
            /*display: flex;*/
            flex-direction: column;
            gap: 10px;
        }

        textarea {
            width: 100%;
            height: auto; /* 自動リサイズのためにautoに */
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: 'Meiryo', 'Hiragino Kaku Gothic ProN', 'BIZ UDPGothic', sans-serif;
            font-size: 1em;
            line-height: 1.6;
            resize: none; /* デフォルトはなし */
            box-sizing: border-box;
            min-height: 50px;
            overflow: hidden; /* スクロールバーは表示しない */
        }

        .main-textarea {
            flex-grow: 1;
            min-height: 150px;
            resize: vertical; /* メインエディタもマニュアルリサイズ可能に */
        }

        .outline-textarea {
            min-height: 50px;
            max-height: none; /* max-heightを削除 (自動で伸びる) */
            resize: vertical; 
        }

        .character-textarea { 
            min-height: 70vh; 
            max-height: none; /* max-heightを削除 (自動で伸びる) */
            resize: vertical; 
            overflow-y: auto; /* キャラクターは内容が多いのでスクロール許可 */
        }
        
        /* シーン/ページ/セリフの動的表示用スタイル */
        .item-wrapper {
            display: flex;
            align-items: flex-start;
            padding: 2px 0;
            border-bottom: 1px dashed #eee;
            margin-bottom: 2px;
            font-family: 'Meiryo', 'Hiragino Kaku Gothic ProN', 'BIZ UDPGothic', sans-serif;
            font-size: 0.95em;
            line-height: 1.6;
            box-sizing: border-box;
            flex-shrink: 0;
            word-wrap: break-word;
            white-space: pre-wrap;
        }
        .item-wrapper textarea {
            flex-grow: 1;
            margin: 0;
            padding: 0;
            border: none;
            background: transparent;
            font-size: 1em;
            line-height: inherit;
            resize: none;
            overflow: hidden; /* スクロールバーは表示しない */
            height: auto;
            box-sizing: border-box;
        }

        /* シーンのtextarea */
        .scene-item-container textarea {
            width: 100%;
            border: 1px solid #ddd;
            border-top: none;
            padding: 5px;
            box-sizing: border-box;
            background-color: white;
            border-radius: 0;
            padding: 5px;
            overflow: hidden; 
            min-height: 40px; /* シーン説明の最小の高さ */
            max-height: none; 
            resize: none; 
            height: auto; 
        }
        
        /* ページとセリフのtextarea */
        .page-item-container textarea{ /*,}.dialogue-content textarea { */
            width: 100%;
            border: 1px solid #ddd;
            padding: 5px;
            box-sizing: border-box;
            background-color: white;
            border-radius: 0;
            overflow: hidden; 
            min-height: 40px; /* ページ説明・セリフの最小の高さ */
            max-height: none; 
            resize: none; 
            height: auto; 
        }


        .item-wrapper .content-display {
            flex-grow: 1;
            margin: 0;
            padding: 0;
            border: none;
            background: transparent;
            font-size: 1em;
            line-height: inherit;
            white-space: pre-wrap;
            word-wrap: break-word;
            min-height: 1.6em;
        }

        .line-numbers {
            width: 35px;
            text-align: right;
            padding-right: 5px;
            color: #aaa;
            font-size: 0.8em;
            flex-shrink: 0;
            user-select: none;
        }

        /* ファイルドロップ時のスタイル (このレイアウトでは直接見えないかもしれない) */
        body.drag-over .column.main-column {
            box-shadow: 0 0 15px rgba(0, 123, 255, 0.5);
            border: 2px dashed #007bff;
        }

        /* シーンカラム内の追加ボタン */
        .add-button-container {
            text-align: center;
            margin: 0;
            padding-top: 5px;
            border-top: 1px dashed #eee;
            margin-bottom: 10px;
        }
        .add-button-container button {
            background-color: #17A2B8;
            color: white;
            padding: 5px 10px;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.9em;
            width: 100%;
            box-sizing: border-box;
            margin: 0 auto;
            display: block;
        }
        .add-button-container button:hover {
            background-color: #138496;
        }

        /* シーンアイテムの具体的なスタイル */
        .scene-item-container {
            border: 1px solid #ccc;
            padding: 0px;
            margin-bottom: 10px;
            border-radius: 5px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
            display: flex;
            flex-direction: column;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        }
        /* アクティブな要素の強調表示 */
        .scene-item-container.active,
        .page-item-container.active,
        .dialogue-content.active,
        .character-item-container.active { 
            box-shadow: 0 0 8px 3px rgba(0, 123, 255, 0.5);
            border-color: #007bff;
            transform: scale(1.01);
        }

        .page-item-container {
            border: 1px solid #ccc;
            padding: 0px;
            margin: 0;
            margin-bottom: 5px;
            border-radius: 5px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
            cursor: pointer;
            transition: background-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        }

        /* シーンの背景色ローテーション用クラス */
        .scene-color-0 { background-color: #e0f7fa; }
        .scene-color-1 { background-color: #f0f4c3; }
        .scene-color-2 { background-color: #ffe0b2; } 
        .scene-color-3 { background-color: #e1bee7; }
        .scene-color-4 { background-color: #b3e5fc; }

        /* セリフ表示部分のスタイル */
        .serif-page-group-container {
            border: 1px solid #dcdcdc;
            border-radius: 5px;
            margin-bottom: 15px;
            padding: 10px;
            padding-top: 0;
            background-color: #fffbf0; /* 薄いオレンジ色 #fffbf0 に変更 */
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
            box-sizing: border-box;
            cursor: pointer;
        }


        .dialogue-content {
            margin-bottom: 8px;
            border-radius: 5px;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            box-sizing: border-box;
            cursor: pointer;
            transition: none;
            flex-grow: 1;
            white-space: pre-wrap;
            word-wrap: break-word;
            font-size: 0.95em;
            line-height: 1.6;
            font-style:italic; /* 親のitalicを打ち消す */
            color: #333;
            background-color: white; /* 各セリフdivの背景は白に */
            border-radius: 3px;
            width: 100%;
            border: 1px solid #ddd;
            border-left: 3px solid #f9ab00; /* セリフのdivに左ボーダーを適用 */
            padding: 5px; /* ボーダー分の調整と内容のパディング */
        }
        /* セリフのdiv内のテキストは直接表示されるので、textareaのスタイルは不要 */


        .scene-item-header, .page-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 10px; /* シーンとページで共通のパディング */
            flex-shrink: 0;
        }

        .scene-title-badge {
            background-color: #007bff;
            color: white;
            padding: 3px 8px;
            border-radius: 4px;
            font-weight: bold;
            font-size: 1.0em;
            display: inline-block;
        }

        .page-title-badge {
            background-color: #007bff;
            color: white;
            padding: 3px 8px;
            border-radius: 4px;
            font-weight: bold;
            font-size: 1.0em;
            display: inline-block;
        }

        .scene-item-header .delete-scene-btn, .page-item-header .delete-page-btn {
            background-color: #dc3545;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.8em;
            transition: background-color 0.2s;
        }

        .scene-item-header .delete-scene-btn:hover, .page-item-header .delete-page-btn:hover {
            background-color: #c82333;
        }

        .section-container {
            border: 1px solid #ccc;
            border-radius: 5px;
            margin-bottom: 10px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
            background-color: #f8f8f8;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .section-header {
            background-color: #f0f0f0;
            padding: 8px 10px;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: bold;
            flex-shrink: 0;
            cursor: pointer;
        }

        .section-header h3 {
            margin: 0;
            font-size: 1em;
            color: #333;
            flex-grow: 1;
        }

        .toggle-btn, .add-character-btn {
            background-color: #6c757d;
            color: white;
            padding: 4px 8px;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.8em;
            transition: background-color 0.2s;
            margin-left: 5px;
        }

        .toggle-btn:hover, .add-character-btn:hover {
            background-color: #5a6268;
        }

        .section-content {
            padding: 10px;
            transition: max-height 0.3s ease-out, opacity 0.3s ease-out, padding 0.3s ease-out;
            overflow-y: auto; 
            max-height: none; 
            opacity: 1;
            box-sizing: border-box;
        }

        .section-content.hidden {
            max-height: 0 !important;
            padding-top: 0;
            padding-bottom: 0;
            opacity: 0;
            visibility: hidden;
        }

        /* .character-textarea, .outline-textarea, .main-textarea は個別の max-height を持つ */
        .character-textarea, .outline-textarea, .main-textarea {
            border: none;
            min-height: 50px;
            background-color: white;
            border-radius: 0;
            padding: 5px;
        }

        .main-textarea {
            min-height: 150px;
        }

        /* 個別のシーン内でページを追加するためのボタン */
        .add-page-to-scene-btn {
            background-color: #34495e;
            color: white;
            padding: 5px 10px;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.9em;
            width: calc(100% - 20px); /* Padding分を考慮 */
            box-sizing: border-box;
            margin: 10px; /* シーンアイテムの下に少しマージン */
            display: block;
            text-align: center;
        }
        .add-page-to-scene-btn:hover {
            background-color: #2c3e50; /* ホバー時の色 */
        }
/*タブバー*/
        .tab-bar {
            display: none; /* PCでは非表示 */
            background:white;
            border-top:1px solid #ddd;
            flex-shrink: 0;
            box-shadow: 0 -2px 4px rgba(0,0,0,0.05 );
            z-index:1000; /* 最前面に表示 */
            position: fixed; /* 画面下部に固定 */
            bottom: 0;
            left: 0;
            right: 0;
            height: 60px; /* タブバーの高さ */
            box-sizing: border-box;
        }
        .tab-item {
            flex: 1;
            padding: 8px 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 2px;
            cursor: pointer;
            transition: background 0.2s;
            position: relative;
            color: #666;
        }
        
        .tab-item:active {
            background: #f0f0f0;
        }
        
        .tab-item.active::before {
            content: '';
            position: absolute;
            top: 0;
            left: 10%;
            right: 10%;
            height: 3px;
            background: #1a73e8;
            border-radius: 0 0 3px 3px;
        }
        
        .tab-icon {
            font-size: 22px;
        }
        
        .tab-label {
            font-size: 10px;
        }
        
        .tab-item.active {
            color: #1a73e8;
        }


        /* --- スマートフォン対応のためのメディアクエリ --- */
        @media (max-width: 768px) {
            body {
                overflow-y: hidden; /* 全体スクロールを禁止 (横スライドのため) */
                padding-bottom:60px;/*タブバーの高さ分、bodyに余白を設ける*/
            }
            .tab-bar {
                display: flex; /* スマホの時だけ表示 */
            }
            .columns-wrapper {
                width: 400vw; /* 4カラム分の幅 */
                transform: translateX(0vw); /* 初期表示はJSで設定 */
                transition: transform 0.3s ease-in-out; /* スライドアニメーション */
                padding-top: 0; /* グローバルヘッダーを削除したので0 */
                padding-bottom: 0; /* フッターナビを削除したので0 */
                box-sizing: border-box;
                overflow-x: hidden; /* 横スクロール禁止 (JSで制御するため) */
            }

            .column {
                width: 100vw; /* 各カラムの幅をビューポートの幅に */
                border-right: none; /* スマホではカラム間の境界線は不要 */
            }

            .column-header {
                flex-direction: column;
                align-items: flex-start;
                padding: 8px;
            }

            .column-header .header-title {
                margin-right: 0;
                margin-bottom: 5px;
            }

            .column-header .controls {
                width: 100%;
                justify-content: space-around;
                gap: 5px;
            }

            .column-header .controls button {
                flex-grow: 1;
                margin-left: 0;
                padding: 8px 5px;
                font-size: 1em;
            }

            .column-content {
                padding: 8px;
            }

            /* スマホ時のsection-contentのmax-heightも調整 */
            .section-content {
                max-height: none; /* スマホでも内部のtextareaがスクロールするように */
            }
        }

        @media (max-width: 480px) {
            .column-header .controls button {
                font-size: 0.9em;
                padding: 6px 3px;
            }

            .section-header h3 {
                font-size: 0.9em;
            }
            .toggle-btn, .add-character-btn {
                font-size: 0.7em;
                padding: 3px 6px;
            }
            
            textarea {
                font-size: 0.9em;
            }
            .line-numbers {
                width: 25px;
                font-size: 0.7em;
            }

            .section-content {
                max-height: none; /* スマホでも内部のtextareaがスクロールするように */
            }
        }
    </style>
</head>
<body>
    <div class="columns-wrapper" id="columnsWrapper">
        <div class="column main-column" data-column-id="main">
            <div class="column-header">
                <span class="header-title">メイン</span>
                <div class="controls">
                    <button id="newBtn">新規</button>
                    <button id="openBtn">開く</button>
                    <input type="file" id="fileInput" style="display: none;">
                    <button id="saveBtn">保存</button>
                    <button id="saveAsBtn">別名保存</button>
                    <button id="undoBtn">↶</button>
                    <button id="redoBtn">↷</button>
                </div>
            </div>
            <div class="column-content">
                <div class="section-container" id="outlineSection">
                    <div class="section-header">
                        <h3>アウトライン</h3>
                        <button class="toggle-btn" data-target="outlineContent">隠す</button>
                    </div>
                    <div class="section-content" id="outlineContent">
                        <textarea id="outlineEditor" class="outline-textarea" placeholder="ここに物語のアウトラインを記述してください。"></textarea>
                    </div>
                </div>
                
                <div class="section-container" id="characterSection">
                    <div class="section-header">
                        <h3>キャラクター</h3>
                        <div class="controls">
                            <button class="add-character-btn" id="addCharacterBtn">追加</button>
                            <button class="toggle-btn" data-target="characterContent">隠す</button>
                        </div>
                    </div>
                    <div class="section-content" id="characterContent">
                        <textarea id="characterEditor" class="character-textarea"></textarea>
                    </div>
                </div>

                <div class="section-container" id="mainEditorSection">
                    <div class="section-header">
                        <h3>ネーム本体 (XML)</h3>
                        <button class="toggle-btn" data-target="mainEditorContent">隠す</button>
                    </div>
                    <div class="section-content" id="mainEditorContent">
                        <textarea id="mainEditor" class="main-textarea" placeholder="XML形式でネームを記述してください。例：
<root><シーン><シーン説明>新しいシーン</シーン説明><ページ><ページ説明>新しいページ</ページ説明><セリフ>セリフA</セリフ></ページ></シーン></root>">
</textarea>
                    </div>
                </div>
            </div>
        </div>

        <div class="column scene-column" data-column-id="scene">
            <div class="column-header">
                <span class="header-title">シーン</span>
                <div class="controls">
                    <button id="addSceneBtn">シーン追加</button>
                </div>
            </div>
            <div class="column-content" id="sceneContent">
                <p>メインエディタの内容からシーンを抽出します。</p>
            </div>
        </div>

        <div class="column page-column" data-column-id="page">
            <div class="column-header">
                <span class="header-title">ページ</span>
            </div>
            <div class="column-content" id="pageContent">
                <p>メインエディタの内容からページを抽出します。</p>
            </div>
        </div>

        <div class="column serif-column" data-column-id="serif">
            <div class="column-header">
                <span class="header-title">セリフ</span>
                <div class="controls">
                    <button id="exportDialogueBtn">エクスポート</button>
                </div>
            </div>
            <div class="column-content" id="dialogueContent">
                <p>メインエディタの内容からセリフを抽出します。</p>
            </div>
        </div>
    </div>

<!-- タブバー（モバイル用） -->
    <div class="tab-bar">
        <div class="tab-item active" data-page="0" onclick="switchToPage(0)">
            <span class="tab-icon">📝</span>
            <span class="tab-label">メイン</span>
        </div>
        <div class="tab-item" data-page="1" onclick="switchToPage(1)">
            <span class="tab-icon">🎬</span>
            <span class="tab-label">シーン</span>
        </div>
        <div class="tab-item" data-page="2" onclick="switchToPage(2)">
            <span class="tab-icon">📄</span>
            <span class="tab-label">ページ</span>
        </div>
        <div class="tab-item" data-page="3" onclick="switchToPage(3)">
            <span class="tab-icon">💬</span>
            <span class="tab-label">セリフ</span>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const outlineEditor = document.getElementById('outlineEditor');
            const characterEditor = document.getElementById('characterEditor');
            const mainEditor = document.getElementById('mainEditor');

            const sceneContentDiv = document.getElementById('sceneContent');
            const pageContentDiv = document.getElementById('pageContent');
            const dialogueContentDiv = document.getElementById('dialogueContent');

            const newBtn = document.getElementById('newBtn');
            const openBtn = document.getElementById('openBtn');
            const saveBtn = document.getElementById('saveBtn');
            const saveAsBtn = document.getElementById('saveAsBtn');
            const fileInput = document.getElementById('fileInput');
            const undoBtn = document.getElementById('undoBtn');
            const redoBtn = document.getElementById('redoBtn');

            const outlineContentDiv = document.getElementById('outlineContent');
            const characterContentDiv = document.getElementById('characterContent');
            const mainEditorContentDiv = document.getElementById('mainEditorContent');

            const toggleButtons = document.querySelectorAll('.toggle-btn');

            const addSceneBtn = document.getElementById('addSceneBtn'); 
            const addCharacterBtn = document.getElementById('addCharacterBtn');
            const exportDialogueBtn = document.getElementById('exportDialogueBtn');

            const columnsWrapper = document.getElementById('columnsWrapper');
            
            let currentFileName = '新規ネーム.txt';
            let history = [''];
            let historyIndex = 0;
            const MAX_HISTORY = 100;
            let updateTimeout;
            const DEBOUNCE_DELAY = 300; 
            let currentXmlDoc = null;
            let currentFileHandle = null;

            const xmlParser = new DOMParser();
            // const xmlSerializer = new XMLSerializer(); // XMLSerializerは使用しない

            let nodeIdCounter = 0; 

            // XMLノードとDOM要素の関連付け用マップ
            const sceneNodeIdToDomElementMap = new Map();
            const pageNodeIdToDomElementMap = new Map();
            const sceneNodeIdToFirstPageDomElementMap = new Map();
            const dialogueNodeIdToDomElementMap = new Map(); 

            let activeSceneElement = null;
            let activePageElement = null;
            let activeDialogueElement = null; // 個別のセリフ要素

            // --- カラム表示制御用の変数 ---            
            let currentColumnIndex = 0; // 0:メイン, 1:シーン, 2:ページ, 3:セリフ
            const columns = document.querySelectorAll('.column');
            let startX = 0;
            let currentTranslateX = 0;
            let isDragging = false;

            function showColumn(index) {
                if (index < 0 || index >= columns.length) return;
                currentColumnIndex = index;
                saveState(); // カラム移動時にも状態を保存

                if (window.innerWidth <= 768) {
                    columnsWrapper.style.transform = `translateX(-${index * 100}vw)`;
                    
                    // --- タブのアクティブ状態を更新 ---
                    const tabs = document.querySelectorAll('.tab-item');
                    tabs.forEach(tab => tab.classList.remove('active'));
                    const activeTab = document.querySelector(`.tab-item[data-page='${index}']`);
                    if (activeTab) {
                        activeTab.classList.add('active');
                    }
                    // --- ここまで追加 ---

                } else {
                    // PC表示時の挙動 (変更なし)
                    columnsWrapper.style.transform = `translateX(0)`; 
                    columnsWrapper.style.scrollBehavior = 'smooth'; 
                    columnsWrapper.scrollLeft = columns[index].offsetLeft;
                }
            }

            function switchToPage(index) {
                if (window.innerWidth > 768) {
                    // PC表示の場合は何もしないか、もしくはスクロール移動
                    columnsWrapper.style.scrollBehavior = 'smooth'; 
                    columns[index].scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'start' });
                    return;
                }
                // モバイル表示の場合はカラムをスライド
                showColumn(index);
            }

            function undo() {
                if (historyIndex > 0) {
                    historyIndex--;
                    mainEditor.value = history[historyIndex];
                    updateUIImmediate(); // UIを即座に更新
                }
            }

            function redo() {
                if (historyIndex < history.length - 1) {
                    historyIndex++;
                    mainEditor.value = history[historyIndex];
                    updateUIImmediate(); // UIを即座に更新
                }
            }

            function saveState() {
                const state = {
                    outlineContent: outlineEditor.value,
                    characterContent: characterEditor.value,
                    mainContent: mainEditor.value,
                    fileName: currentFileName,
                    history: history,
                    historyIndex: historyIndex,
                    outlineHidden: outlineContentDiv.classList.contains('hidden'),
                    characterHidden: characterContentDiv.classList.contains('hidden'),
                    mainEditorHidden: mainEditorContentDiv.classList.contains('hidden'),
                    currentColumnIndex: currentColumnIndex 
                };
                localStorage.setItem('comicNameEditorState', JSON.stringify(state));
                console.log('State saved.');
            }

            function clearAllEditors() {
                outlineEditor.value = '';
                characterEditor.value = `*主人公（名前：読み方、愛称）男女、歳
*関係性
*見た目、身体的特徴、服装
*性格・裏性格
*環境・生い立ち
――――――――――
*ヒロイン（名前：読み方、愛称）男女、歳
*関係性
*見た目、身体的特徴、服装
*性格・裏性格
*環境・生い立ち
――――――――――
*ライバル（名前：読み方、愛称）男女、歳
*関係性
*見た目、身体的特徴、服装
*性格・裏性格
*環境・生い立ち`;

                // 新規作成時のXML初期値に、空のセリフ要素も含むように変更
                mainEditor.value = `<root><シーン><シーン説明>新しいシーン</シーン説明><ページ><ページ説明>新しいページ</ページ説明></ページ></シーン></root>`; 
                currentFileName = '新規ネーム.txt';
                currentFileHandle = null;
                history = [mainEditor.value];
                historyIndex = 0;
                localStorage.removeItem('comicNameEditorState');
                
                setSectionVisibility(outlineContentDiv, false);
                setSectionVisibility(characterContentDiv, false);
                setSectionVisibility(mainEditorContentDiv, true);

                currentColumnIndex = 0; 
                showColumn(currentColumnIndex); 
                updateUIImmediate();
                alert('新しいネームを開始しました。');
            }


            function loadState() {
                const savedState = localStorage.getItem('comicNameEditorState');
                if (savedState) {
                    const state = JSON.parse(savedState);
                    outlineEditor.value = state.outlineContent || '';
                    characterEditor.value = state.characterContent || '';
                    mainEditor.value = state.mainContent || '';
                    currentFileName = state.fileName || '新規ネーム.txt';
                    history = state.history || [''];
                    historyIndex = state.historyIndex || 0;

                    setSectionVisibility(outlineContentDiv, state.outlineHidden || false);
                    setSectionVisibility(characterContentDiv, state.characterHidden || false);
                    setSectionVisibility(mainEditorContentDiv, state.mainEditorHidden || false);
                    
                    currentColumnIndex = state.currentColumnIndex !== undefined ? state.currentColumnIndex : 0; 
                    console.log('State loaded.');
                } else {
                    outlineEditor.value = '';
                    characterEditor.value = `*主人公（名前：読み方、愛称）男女、歳
*関係性
*見た目、身体的特徴、服装
*性格・裏性格
*環境・生い立ち
――――――――――
*ヒロイン（名前：読み方、愛称）男女、歳
*関係性
*見た目、身体的特徴、服装
*性格・裏性格
*環境・生い立ち
――――――――――
*ライバル（名前：読み方、愛称）男女、歳
*関係性
*見た目、身体的特徴、服装
*性格・裏性格
*環境・生い立ち`;

                    // 初期XML値もセリフが空でもタグがあるように変更
mainEditor.value = `<root><シーン><シーン説明>新しいシーン</シーン説明><ページ><ページ説明>新しいページ</ページ説明></ページ></シーン></root>`; 
                    history = [mainEditor.value];
                    historyIndex = 0;

                    setSectionVisibility(outlineContentDiv, false);
                    setSectionVisibility(characterContentDiv, false);
                    setSectionVisibility(mainEditorContentDiv, true);
                    currentColumnIndex = 0; 
                }
                showColumn(currentColumnIndex); 
                updateUIImmediate();
                // autoResizeAllTextareas(); // これはupdateUIImmediate内でsetTimeoutで呼び出す
            }

            function setSectionVisibility(contentDiv, isHidden) {
                const toggleBtn = contentDiv.previousElementSibling.querySelector('.toggle-btn');
                const addCharBtn = contentDiv.previousElementSibling.querySelector('.add-character-btn');
                if (isHidden) {
                    contentDiv.classList.add('hidden');
                    if (toggleBtn) toggleBtn.textContent = '開く';
                    if (addCharBtn) addCharBtn.style.display = 'none';
                } else {
                    contentDiv.classList.remove('hidden');
                    if (toggleBtn) toggleBtn.textContent = '隠す';
                    if (addCharBtn) addCharBtn.style.display = 'inline-block';
                }
                if (!isHidden && contentDiv.querySelector('textarea')) { 
                    autoResizeTextArea(contentDiv.querySelector('textarea'));
                }
            }

            function updateUI() {
                clearTimeout(updateTimeout);
                updateTimeout = setTimeout(() => {
                    updateUndoRedoButtons();
                    syncColumnsFromMainEditor();
                    setTimeout(autoResizeAllTextareas, 50); // Small delay
                    saveState();
                    console.log('UI updated and State saved (debounced).');
                }, DEBOUNCE_DELAY);
            }

            function updateUIImmediate() {
                updateUndoRedoButtons();
                syncColumnsFromMainEditor();
                setTimeout(autoResizeAllTextareas, 50); // Small delay to ensure DOM is rendered before resizing
                saveState();
                console.log('UI updated and State saved (immediate).');
            }

            function updateUndoRedoButtons() {
                undoBtn.disabled = historyIndex === 0;
                redoBtn.disabled = historyIndex === history.length - 1;
            }

            function addToHistory(content) {
                if (history.length > 0 && history[historyIndex] === content) {
                    return;
                }
                if (historyIndex < history.length - 1) {
                    history = history.slice(0, historyIndex + 1);
                }
                history.push(content);
                if (history.length > MAX_HISTORY) {
                    history.shift();
                } else {
                    historyIndex++;
                }
                updateUndoRedoButtons();
            }

            openBtn.addEventListener('click', async () => {
                try {
                    const [fileHandle] = await window.showOpenFilePicker({
                        types: [
                            {
                                description: 'Text Files',
                                accept: {
                                    'text/plain': ['.txt'],
                                },
                            },
                        ],
                    });
                    const file = await fileHandle.getFile();
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        extractAndSetSeparateContents(event.target.result);
                        currentFileName = file.name;
                        currentFileHandle = fileHandle;
                        history = [mainEditor.value];
                        historyIndex = 0;
                        updateUIImmediate();
                    };
                    reader.onerror = () => {
                        alert('ファイルの読み込みに失敗しました。');
                    };
                    reader.readAsText(file);
                } catch (err) {
                    if (err.name === 'AbortError') {
                        console.log('File picker was cancelled.');
                    } else {
                        console.error('Error opening file:', err);
                        alert('ファイルのオープン中にエラーが発生しました。');
                    }
                }
            });

            async function saveContentToDisk(handle = null, silent = false) { // silent引数を追加
                const xmlContent = mainEditor.value;
                const fullContentToSave = `[アウトライン:]\n${outlineEditor.value}\n\n` +
                                          `[キャラクター:]\n${characterEditor.value}\n\n` +
                                          `[ネーム本体(XML):]\n${xmlContent}\n\n` +
                                          `[セリフ一覧(今後廃止):]\n`;

                try {
                    if (handle) { // fileHandleが渡された場合（簡易保存）
                        try {
                            const writable = await handle.createWritable();
                            await writable.write(fullContentToSave);
                            await writable.close();
                            if (!silent) { // silentがtrueの場合はアラートを出さない
                                alert(`ファイルを保存しました: ${handle.name}`);
                            }
                            currentFileHandle = handle; // 成功したハンドルを現在のハンドルとして保持
                            currentFileName = handle.name;
                            return true; // 成功したらtrueを返す
                        } catch (writeError) {
                            console.warn('簡易保存に失敗しました。別名保存を試みます:', writeError); // ファイルが移動されたなどで上書き保存できない場合は、フォールバックで別名保存
                        }
                    }

                    // handleがnullの場合、または簡易保存に失敗した場合
                    const newHandle = await window.showSaveFilePicker({
                        types: [
                            {
                                description: 'Text Files',
                                accept: {
                                    'text/plain': ['.txt'],
                                },
                            },
                        ],
                        suggestedName: currentFileName
                    });
                    const writable = await newHandle.createWritable();
                    await writable.write(fullContentToSave);
                    await writable.close();
                    if (!silent) { // silentがtrueの場合はアラートを出さない
                        alert(`ファイルを保存しました: ${newHandle.name}`);
                    }
                    currentFileHandle = newHandle; // 新しいファイルハンドルを保存
                    currentFileName = newHandle.name; // 新しいファイル名を保存
                    return true; // 成功したらtrueを返す
                } catch (err) {
                    if (err.name === 'AbortError') {
                        console.log('Save operation was cancelled.');
                    } else {
                        console.error('Error saving file:', err);
                        alert('ファイルの保存中にエラーが発生しました。');
                    }
                    return false; // 失敗したらfalseを返す
                }
            }

            saveBtn.addEventListener('click', async () => {
                if (currentFileHandle) { // 既にファイルハンドルが存在する場合
                    const overwriteConfirmed = confirm(`「${currentFileName}」に上書き保存しますか？\n\nキャンセルを選ぶと、名前を変えて保存するか選択できます。`);
                    if (overwriteConfirmed) { // はい（上書き）
                        await saveContentToDisk(currentFileHandle, false); // silentをfalseにしてアラートを出す
                    } else { // いいえ（キャンセル） -> 名前を変えて保存するか尋ねる
                        const saveAsConfirmed = confirm('名前を変えて保存しますか？');
                        if (saveAsConfirmed) { // はい（名前を変えて保存）
                            await saveContentToDisk(null, false); // silentをfalseにしてアラートを出す
                        }
                        // いいえ（キャンセル） -> 何もしない
                    }
                } else { // ファイルハンドルがまだ存在しない場合（初回保存）
                    await saveContentToDisk(null, false); // silentをfalseにしてアラートを出す
                }
            });

            saveAsBtn.addEventListener('click', async () => {
                // 常に別名保存ダイアログを開く
                await saveContentToDisk(null, false); // silentをfalseにしてアラートを出す
            });

            const mainColumn = document.querySelector('.column.main-column');
            document.body.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.stopPropagation();
                if (window.innerWidth > 768) {
                    document.body.classList.add('drag-over');
                }
            });

            document.body.addEventListener('dragleave', (e) => {
                if (window.innerWidth > 768) {
                    if (!mainColumn.contains(e.relatedTarget) && e.relatedTarget !== null) {
                        document.body.classList.remove('drag-over');
                    }
                }
            });

            mainColumn.addEventListener('drop', async (e) => {
                e.preventDefault();
                document.body.classList.remove('drag-over');

                const file = e.dataTransfer.files[0];
                if (file && file.type === 'text/plain') {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        extractAndSetSeparateContents(event.target.result);
                        currentFileName = file.name;
                        currentFileHandle = null; // ドラッグ＆ドロップで開いた場合はハンドルをリセット
                        history = [mainEditor.value];
                        historyIndex = 0;
                        updateUIImmediate();
                    };
                    reader.onerror = () => {
                        alert('ファイルの読み込みに失敗しました。');
                    };
                    reader.readAsText(file);
                }
            });

            function extractAndSetSeparateContents(fullText) {
                const extracted = { outline: '', character: '', main: '' };

                const outlineMatch = fullText.match(/\[アウトライン:\]\n([\s\S]*?)(?=\n*\[キャラクター:\]|\n*\[ネーム本体\(XML\):\]|\n*\[セリフ一覧\(今後廃止\):\]|$)/);
                if (outlineMatch) extracted.outline = outlineMatch[1].trim();
                else if (fullText.includes('[アウトライン:]')) extracted.outline = ''; // タグはあるが内容がない場合

                const characterMatch = fullText.match(/\[キャラクター:\]\n([\s\S]*?)(?=\n*\[ネーム本体\(XML\):\]|\n*\[セリフ一覧\(今後廃止\):\]|$)/);
                if (characterMatch) extracted.character = characterMatch[1].trim();
                else if (fullText.includes('[キャラクター:]')) extracted.character = ''; // タグはあるが内容がない場合

                const mainXmlMatch = fullText.match(/\[ネーム本体\(XML\):\]\n([\s\S]*?)(?=\n*\[セリフ一覧\(今後廃止\):\]|$)/);
                if (mainXmlMatch) extracted.main = mainXmlMatch[1].trim();
                else if (fullText.includes('[ネーム本体(XML):]')) extracted.main = ''; // タグはあるが内容がない場合
                
                // どのセクションタグも見つからなかった場合は、mainEditorに全て入れる
                if (!outlineMatch && !characterMatch && !mainXmlMatch) {
                    extracted.main = fullText;
                }

                outlineEditor.value = extracted.outline;
                characterEditor.value = extracted.character;
                mainEditor.value = extracted.main;
            }

            // カスタムXMLシリアライズ関数
            function serializeXmlToCompactString(node) {
                let result = '';

                if (!node) {
                    return result;
                }

                if (node.nodeType === Node.ELEMENT_NODE) {
                    result += `<${node.tagName}>`;
                    for (let child of node.childNodes) {
                        result += serializeXmlToCompactString(child);
                    }
                    result += `</${node.tagName}>`;
                } else if (node.nodeType === Node.TEXT_NODE) {
                    // XMLエンティティをエスケープ
                    result += node.textContent
                                .replace(/&/g, '&amp;')
                                .replace(/</g, '&lt;')
                                .replace(/>/g, '&gt;')
                                .replace(/"/g, '&quot;')
                                .replace(/'/g, '&apos;');
                } else if (node.nodeType === Node.CDATA_SECTION_NODE) {
                    result += `<![CDATA[${node.textContent}]]>`;
                } else if (node.nodeType === Node.COMMENT_NODE) {
                    result += ``;
                }
                // 他のノードタイプは無視
                return result;
            }


            function syncColumnsFromMainEditor() {
                const mainText = mainEditor.value;

                // マップをクリアして再構築
                sceneNodeIdToDomElementMap.clear();
                pageNodeIdToDomElementMap.clear();
                sceneNodeIdToFirstPageDomElementMap.clear();
                dialogueNodeIdToDomElementMap.clear();
                nodeIdCounter = 0; // ノードIDカウンターをリセット

                try {
                    let textToParse = mainText.trim();
                    if (!textToParse.startsWith('<root>') || !textToParse.endsWith('</root>')) {
                        // rootタグがない場合でもパースを試みるが、エラーになる可能性を考慮
                        textToParse = `<root>${textToParse}</root>`; 
                    }
                    currentXmlDoc = xmlParser.parseFromString(textToParse, 'application/xml');

                    const parserError = currentXmlDoc.querySelector('parsererror');
                    if (parserError) {
                        console.error('XML Parsing Error:', parserError.textContent);
                        const errorMessage = '<p style="color: red;">XMLパースエラー: メインエディタの記述を確認してください。</p>';
                        sceneContentDiv.innerHTML = errorMessage;
                        pageContentDiv.innerHTML = errorMessage;
                        dialogueContentDiv.innerHTML = errorMessage;
                        return; // <--- IMPORTANT: Returns here on parse error.
                    }
                } catch (e) {
                    console.error('Failed to parse XML:', e);
                    const errorMessage = '<p style="color: red;">XMLパースに失敗しました。</p>';
                    sceneContentDiv.innerHTML = errorMessage;
                    pageContentDiv.innerHTML = errorMessage;
                    dialogueContentDiv.innerHTML = errorMessage;
                    return; // <--- IMPORTANT: Returns here on parse error.
                }

                const scenes = currentXmlDoc.querySelectorAll('シーン');
                const sceneItems = [];
                scenes.forEach((sceneElement, index) => {
                    const nodeId = `node-${nodeIdCounter++}`; 
                    sceneItems.push({
                        title: `シーン${index + 1}`,
                        text: sceneElement.querySelector('シーン説明')?.textContent || '',
                        nodeId: nodeId, 
                        rawNode: sceneElement, 
                        sceneIndex: index
                    });
                });
                renderSceneColumnContent(sceneContentDiv, sceneItems);

                // --- ページカラムの描画 ---
                pageContentDiv.innerHTML = '';
                let globalPageIndex = 1;
                if (scenes.length === 0) {
                    const p = document.createElement('p');
                    p.textContent = `メインエディタの内容からページを抽出します。`;
                    pageContentDiv.appendChild(p);
                } else {
                    scenes.forEach((sceneElement, sceneIndex) => {
                        const sceneNodeIdForDom = [...sceneNodeIdToDomElementMap.keys()].find(key => sceneNodeIdToDomElementMap.get(key).xmlNode === sceneElement);
                        const sceneTitle = `シーン${sceneIndex + 1}`;
                        const sceneColorClass = `scene-color-${sceneIndex % 5}`; 

                        const pagesInScene = sceneElement.querySelectorAll('ページ');
                        
                        if (pagesInScene.length === 0) {
                            const p = document.createElement('p');
                            p.textContent = `このシーンにはページがありません。`;
                            p.style.fontSize = '0.9em';
                            p.style.color = '#777';
                            p.style.marginLeft = '10px';
                            p.style.marginBottom = '10px';
                            pageContentDiv.appendChild(p);
                        } 
                        
                        pagesInScene.forEach((pageElement, pageIndexInScene) => { // pageIndexInSceneを追加
                            const nodeId = `node-${nodeIdCounter++}`;
                            const pageItemContainer = document.createElement('div');
                            pageItemContainer.classList.add('page-item-container');
                            pageItemContainer.setAttribute('data-node-id', nodeId); 
                            pageItemContainer.xmlNode = pageElement; // XMLノードをDOM要素に紐付け
                            pageItemContainer.setAttribute('data-parent-scene-id', sceneNodeIdForDom); // 親シーンのDOM IDを保持
                            pageItemContainer.setAttribute('data-scene-index', sceneIndex); // シーンのインデックス
                            pageItemContainer.setAttribute('data-page-index-in-scene', pageIndexInScene); // シーン内のページインデックス
                            pageItemContainer.classList.add(sceneColorClass); 
                            
                            pageItemContainer.addEventListener('click', (event) => {
                                setActiveElement(pageItemContainer, 'page');
                                showColumn(2); 
                                if (window.innerWidth > 768) { 
                                    pageItemContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });
                                }
                            });

                            const pageHeader = document.createElement('div');
                            pageHeader.classList.add('page-item-header');
                            const pageTitleBadge = document.createElement('span');
                            pageTitleBadge.classList.add('page-title-badge');
                            pageTitleBadge.textContent = `ページ${globalPageIndex}`;
                            pageHeader.appendChild(pageTitleBadge);

                            const deleteButton = document.createElement('button');
                            deleteButton.classList.add('delete-page-btn');
                            deleteButton.textContent = '削除';
                            deleteButton.addEventListener('click', (e) => {
                                e.stopPropagation(); 
                                deletePage(pageItemContainer.xmlNode, `ページ${globalPageIndex}`);
                            });
                            pageHeader.appendChild(deleteButton);
                            pageItemContainer.appendChild(pageHeader);

                            const itemTextArea = document.createElement('textarea');
                            // <ページ説明>と<セリフ>の内容を結合してtextareaに表示
                            let combinedText = '';
                            pageElement.childNodes.forEach(child => {
                                if (child.nodeType === Node.ELEMENT_NODE) {
                                    if (child.tagName === 'ページ説明') {
                                        combinedText += child.textContent;
                                    } else if (child.tagName === 'セリフ') {
                                        combinedText += `「${child.textContent}」`;
                                    }
                                } else if (child.nodeType === Node.TEXT_NODE && child.textContent.trim().length > 0) {
                                    // 要素間のテキストノードも考慮（ただし、今回のXML構造ではあまり発生しないはず）
                                    combinedText += child.textContent;
                                }
                            });
                            itemTextArea.value = combinedText;

                            itemTextArea.classList.add('page-text'); 
                            itemTextArea.placeholder = 'ページ内の説明やセリフ';
                            itemTextArea.addEventListener('input', (e) => {
                                autoResizeTextArea(e.target);
                                // updatePageContentInXmlに、DOM要素の参照とテキスト、そしてシーンとページインデックスを渡す
                                updatePageContentInXml(
                                    pageItemContainer.getAttribute('data-scene-index'),
                                    pageItemContainer.getAttribute('data-page-index-in-scene'),
                                    e.target.value // 入力されたテキスト全体を渡す
                                );
                            });
                            itemTextArea.addEventListener('change', () => { 
                                updateUIImmediate(); 
                            });
                            pageItemContainer.appendChild(itemTextArea);
                            autoResizeTextArea(itemTextArea); 
                            
                            pageContentDiv.appendChild(pageItemContainer);
                            pageNodeIdToDomElementMap.set(nodeId, pageItemContainer);

                            if (!sceneNodeIdToFirstPageDomElementMap.has(sceneNodeIdForDom)) {
                                sceneNodeIdToFirstPageDomElementMap.set(sceneNodeIdForDom, pageItemContainer);
                            }
                            globalPageIndex++;
                        });
                        
                        const addPageButtonForScene = document.createElement('button');
                        addPageButtonForScene.classList.add('add-page-to-scene-btn');
                        addPageButtonForScene.textContent = `「${sceneTitle}」にページを追加`;
                        addPageButtonForScene.setAttribute('data-scene-node-id', sceneNodeIdForDom); 
                        addPageButtonForScene.xmlNode = sceneElement; 
                        addPageButtonForScene.addEventListener('click', (e) => {
                            e.stopPropagation(); 
                            addPageToSpecificScene(sceneElement); 
                        });
                        pageContentDiv.appendChild(addPageButtonForScene);
                    });
                }
                
                // --- セリフカラムの描画 ---
                dialogueContentDiv.innerHTML = '';
                let globalPageIndexForDialogue = 1; // セリフカラム描画用のページカウンターを初期化
                if (scenes.length === 0) {
                    const p = document.createElement('p');
                    p.textContent = `メインエディタの内容からセリフを抽出します。`;
                    dialogueContentDiv.appendChild(p);
                } else {
                    scenes.forEach((sceneElement, sceneIndex) => {
                        const pagesInScene = sceneElement.querySelectorAll('ページ');

                        pagesInScene.forEach((pageElement, pageIndexInScene) => {
                            const dialoguesInPage = pageElement.querySelectorAll('セリフ');
                            // XMLノードとDOM要素の関連付けのために、pageElementのnodeIdを取得
                            const pageNodeIdForDom = [...pageNodeIdToDomElementMap.keys()].find(key => pageNodeIdToDomElementMap.get(key).xmlNode === pageElement);

                            if (dialoguesInPage.length > 0) {
                                // ページごとのセリフをまとめるためのコンテナ
                                const serifPageGroupContainer = document.createElement('div');
                                serifPageGroupContainer.classList.add('serif-page-group-container');

                                // ★★★ ここからが追加・修正部分 ★★★
                                // ページ番号を表示するヘッダーを追加
                                const pageHeader = document.createElement('p');
                                pageHeader.style.fontWeight = 'bold';
                                pageHeader.style.color = '#333';
                                pageHeader.style.fontSize = '0.9em';
                                pageHeader.style.marginBottom = '5px';
                                pageHeader.style.paddingBottom = '5px';
                                pageHeader.style.borderBottom = '1px dashed #ccc';
                                // ページカラムと一貫性を持たせるために、通し番号を使用
                                pageHeader.textContent = `ページ ${globalPageIndexForDialogue}`;
                                serifPageGroupContainer.appendChild(pageHeader);
                                // ★★★ ここまでが追加・修正部分 ★★★

                                dialoguesInPage.forEach((dialogueElement, dialogueIndexInPage) => {
                                    const nodeId = `node-${nodeIdCounter++}`;
                                    const dialogueContentDivItem = document.createElement('div');
                                    dialogueContentDivItem.classList.add('dialogue-content');
                                    dialogueContentDivItem.setAttribute('data-node-id', nodeId);
                                    dialogueContentDivItem.xmlNode = dialogueElement;
                                    dialogueContentDivItem.setAttribute('data-parent-page-id', pageNodeIdForDom);
                                    dialogueContentDivItem.setAttribute('data-scene-index', sceneIndex);
                                    dialogueContentDivItem.setAttribute('data-page-index-in-scene', pageIndexInScene);
                                    dialogueContentDivItem.setAttribute('data-dialogue-index-in-page', dialogueIndexInPage);

                                    dialogueContentDivItem.textContent = dialogueElement.textContent; // divのtextContentに設定
                                    dialogueContentDivItem.style.minHeight = '1.6em'; // 最小の高さを確保
                                    dialogueContentDivItem.style.whiteSpace = 'pre-wrap'; // 改行を反映
                                    dialogueContentDivItem.style.wordWrap = 'break-word'; // 長い単語の折り返し

                                    dialogueContentDivItem.addEventListener('click', (event) => {
                                        setActiveElement(dialogueContentDivItem, 'dialogue');
                                        showColumn(3);
                                        if (window.innerWidth > 768) {
                                            dialogueContentDivItem.scrollIntoView({ behavior: 'smooth', block: 'center' });
                                        }
                                    });

                                    serifPageGroupContainer.appendChild(dialogueContentDivItem); // ページグループに追加
                                    dialogueNodeIdToDomElementMap.set(nodeId, dialogueContentDivItem);
                                });
                                dialogueContentDiv.appendChild(serifPageGroupContainer); // セリフカラム全体に追加
                            }
                            
                            // ページを1つ処理したのでカウンターをインクリメント
                            globalPageIndexForDialogue++;
                        });
                    });
                }
                highlightActiveElements();
            }

            function renderSceneColumnContent(container, sceneItems) {
                container.innerHTML = '';
                if (sceneItems.length === 0) {
                    const p = document.createElement('p');
                    p.textContent = `メインエディタの内容からシーンを抽出します。`;
                    container.appendChild(p);
                    return;
                }

                sceneItems.forEach(item => {
                    const sceneItemContainer = document.createElement('div');
                    sceneItemContainer.classList.add('scene-item-container');
                    sceneItemContainer.classList.add(`scene-color-${item.sceneIndex % 5}`); 
                    sceneItemContainer.setAttribute('data-node-id', item.nodeId); 
                    sceneItemContainer.xmlNode = item.rawNode; 
                    sceneItemContainer.setAttribute('data-scene-index', item.sceneIndex); // シーンのインデックスをDOMに保持
                    
                    const header = document.createElement('div');
                    header.classList.add('scene-item-header');

                    const titleBadge = document.createElement('span');
                    titleBadge.classList.add('scene-title-badge');
                    titleBadge.textContent = item.title;
                    header.appendChild(titleBadge);

                    const deleteButton = document.createElement('button');
                    deleteButton.classList.add('delete-scene-btn');
                    deleteButton.textContent = '削除';
                    deleteButton.addEventListener('click', (e) => {
                        e.stopPropagation(); 
                        deleteScene(sceneItemContainer.xmlNode); 
                    });
                    header.appendChild(deleteButton);
                    sceneItemContainer.appendChild(header);

                    const itemTextArea = document.createElement('textarea');
                    itemTextArea.value = item.text;
                    itemTextArea.classList.add('scene-text'); 
                    itemTextArea.placeholder = 'シーンの説明';
                    itemTextArea.addEventListener('input', (e) => {
                        autoResizeTextArea(e.target);
                        // updateSceneContentInXmlにシーンのインデックスとテキストを渡す
                        updateSceneContentInXml(sceneItemContainer.getAttribute('data-scene-index'), e.target.value); 
                    });
                    itemTextArea.addEventListener('change', () => { 
                        updateUIImmediate(); 
                    });
                    sceneItemContainer.appendChild(itemTextArea);
                    autoResizeTextArea(itemTextArea); 

                    sceneItemContainer.addEventListener('click', () => {
                        setActiveElement(sceneItemContainer, 'scene');
                        const firstPageElement = sceneNodeIdToFirstPageDomElementMap.get(item.nodeId); 
                        if (firstPageElement) {
                            setActiveElement(firstPageElement, 'page');
                            showColumn(2); 
                            if (window.innerWidth > 768) { 
                                setTimeout(() => {
                                    firstPageElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
                                }, 300); 
                            }
                        } else {
                            showColumn(2);
                        }
                    });
                    
                    container.appendChild(sceneItemContainer);
                    sceneNodeIdToDomElementMap.set(item.nodeId, sceneItemContainer);
                });
            }

            // XMLツリーを探索して対象のシーン要素を特定するヘルパー関数
            function getSceneElementByIndex(sceneIndex) {
                const scenes = currentXmlDoc.querySelectorAll('シーン');
                return scenes[sceneIndex] || null;
            }

            // XMLツリーを探索して対象のページ要素を特定するヘルパー関数
            function getPageElementByIndex(sceneIndex, pageIndexInScene) {
                const sceneElement = getSceneElementByIndex(sceneIndex);
                if (sceneElement) {
                    const pages = sceneElement.querySelectorAll('ページ');
                    return pages[pageIndexInScene] || null;
                }
                return null;
            }

            // XMLツリーを探索して対象のセリフ要素を特定するヘルパー関数
            function getDialogueElementByIndex(sceneIndex, pageIndexInScene, dialogueIndexInPage) {
                const pageElement = getPageElementByIndex(sceneIndex, pageIndexInScene);
                if (pageElement) {
                    const dialogues = pageElement.querySelectorAll('セリフ');
                    return dialogues[dialogueIndexInPage] || null;
                }
                return null;
            }


            // シーンの更新関数を修正
            function updateSceneContentInXml(sceneIndex, newText) {
                const sceneElement = getSceneElementByIndex(sceneIndex);
                if (sceneElement) {
                    let sceneDescElement = sceneElement.querySelector('シーン説明');
                    if (!sceneDescElement) {
                        sceneDescElement = currentXmlDoc.createElement('シーン説明');
                        sceneElement.insertBefore(sceneDescElement, sceneElement.firstChild);
                    }
                    sceneDescElement.textContent = newText;
                    mainEditor.value = serializeXmlToCompactString(currentXmlDoc.documentElement); // カスタムシリアライザを使用
                    addToHistory(mainEditor.value);
                }
            }

            // ページの更新関数を修正
            function updatePageContentInXml(sceneIndex, pageIndexInScene, fullPageText) { 
                const pageElement = getPageElementByIndex(sceneIndex, pageIndexInScene);
                if (pageElement) {
                    // 既存の<ページ説明>と<セリフ>要素をすべて削除
                    // これにより、新しい内容で完全に再構築される
                    pageElement.querySelectorAll('ページ説明, セリフ').forEach(el => pageElement.removeChild(el));

                    // 正規表現で「」で囲まれたセリフを抽出
                    // 変更点: 改行を含む任意のアウトラインテキストを考慮できるよう「[^」]*」を「([\s\S]*?)」に変更
                    const dialogueRegex = /「([\s\S]*?)」/g;
                    let lastIndex = 0;
                    let contentParts = []; // ページ説明とセリフの順序を保持する配列

                    let match;
                    while ((match = dialogueRegex.exec(fullPageText)) !== null) {
                        // セリフの前のテキスト（ページ説明の一部）
                        if (match.index > lastIndex) {
                            contentParts.push({ type: 'desc', text: fullPageText.substring(lastIndex, match.index) });
                        }

                        // セリフ本体（「」の中身）
                        const dialogueText = match[1]; 
                        contentParts.push({ type: 'dialogue', text: dialogueText });

                        lastIndex = dialogueRegex.lastIndex;
                    }

                    // 残りのテキスト（最後のセリフの後、またはセリフがない場合）
                    if (lastIndex < fullPageText.length) {
                        contentParts.push({ type: 'desc', text: fullPageText.substring(lastIndex) });
                    }
                    
                    // contentPartsに基づいて新しい要素を作成し、pageElementに追加
                    contentParts.forEach(part => {
                        if (part.type === 'desc') {
                            // 空行だけのページ説明は追加しない (trim()後の長さで判断)
                            // ただし、改行自体は維持するためにtextContentにはそのままセット
                            if (part.text.trim().length > 0 || part.text.includes('\n')) { 
                                const newPageDescElement = currentXmlDoc.createElement('ページ説明');
                                newPageDescElement.textContent = part.text; 
                                pageElement.appendChild(newPageDescElement); 
                            }
                        } else if (part.type === 'dialogue') {
                            const newDialogueElement = currentXmlDoc.createElement('セリフ');
                            newDialogueElement.textContent = part.text;
                            pageElement.appendChild(newDialogueElement);
                        }
                    });

                    mainEditor.value = serializeXmlToCompactString(currentXmlDoc.documentElement); // カスタムシリアライザを使用
                    addToHistory(mainEditor.value);
                }
            }


            // セリフの更新関数はdivになったので、メインエディタ側からは変更しない
            // よって、この関数は削除するか、空にする
            function updateDialogueContentInXml(sceneIndex, pageIndexInScene, dialogueIndexInPage, newText) {
                // セリフカラムは編集不可なので、この関数は呼び出されません
                // もし将来的に編集可能にする場合は、ここでXMLを更新する処理を記述します
                console.log("Dialogue content updated (セリフカラムは編集不可です):", newText);
            }


            function deleteScene(sceneElement) { 
                if (!confirm('このシーンを削除してもよろしいですか？（このシーン内のページとセリフも全て削除されます）')) {
                    return;
                }
                if (sceneElement && sceneElement.parentNode) {
                    sceneElement.parentNode.removeChild(sceneElement);
                    mainEditor.value = serializeXmlToCompactString(currentXmlDoc.documentElement); // カスタムシリアライザを使用
                    addToHistory(mainEditor.value);
                    updateUIImmediate(); 
                }
            }

            function deletePage(pageElement, pageTitle) { 
                if (!confirm(`ページ ${pageTitle} を削除してもよろしいですか？（このページ内のセリフも全て削除されます）`)) {
                    return;
                }
                if (pageElement && pageElement.parentNode) {
                    pageElement.parentNode.removeChild(pageElement);
                    mainEditor.value = serializeXmlToCompactString(currentXmlDoc.documentElement); // カスタムシリアライザを使用
                    addToHistory(mainEditor.value);
                    updateUIImmediate();
                }
            }

            function setActiveElement(element, type) {
                document.querySelectorAll('.active').forEach(el => el.classList.remove('active'));

                if (element) {
                    element.classList.add('active');
                }

                if (type === 'scene') {
                    activeSceneElement = element;
                    activePageElement = null; 
                    activeDialogueElement = null;
                } else if (type === 'page') {
                    activePageElement = element;
                    activeDialogueElement = null; 
                    const parentSceneId = element.getAttribute('data-parent-scene-id');
                    if (parentSceneId) {
                        const parentSceneElement = sceneNodeIdToDomElementMap.get(parentSceneId);
                        if (parentSceneElement && parentSceneElement !== activeSceneElement) {
                            parentSceneElement.classList.add('active');
                            activeSceneElement = parentSceneElement;
                        }
                    }
                } else if (type === 'dialogue') {
                    activeDialogueElement = element;
                    const parentPageId = element.getAttribute('data-parent-page-id');
                    if (parentPageId) {
                        const parentPageElement = pageNodeIdToDomElementMap.get(parentPageId);
                        if (parentPageElement && parentPageElement !== activePageElement) {
                            parentPageElement.classList.add('active');
                            activePageElement = parentPageElement;
                        }
                        const parentSceneId = parentPageElement ? parentPageElement.getAttribute('data-parent-scene-id') : null;
                        if (parentSceneId) {
                            const parentSceneElement = sceneNodeIdToDomElementMap.get(parentSceneId);
                            if (parentSceneElement && parentSceneElement !== activeSceneElement) {
                                parentSceneElement.classList.add('active');
                                activeSceneElement = parentSceneElement;
                            }
                        }
                    }
                }
            }

            function highlightActiveElements() {
                document.querySelectorAll('.active').forEach(el => el.classList.remove('active'));

                if (activeSceneElement && sceneNodeIdToDomElementMap.has(activeSceneElement.getAttribute('data-node-id'))) {
                    sceneNodeIdToDomElementMap.get(activeSceneElement.getAttribute('data-node-id')).classList.add('active');
                }
                if (activePageElement && pageNodeIdToDomElementMap.has(activePageElement.getAttribute('data-node-id'))) {
                    pageNodeIdToDomElementMap.get(activePageElement.getAttribute('data-node-id')).classList.add('active');
                }
                if (activeDialogueElement && dialogueNodeIdToDomElementMap.has(activeDialogueElement.getAttribute('data-node-id'))) {
                    dialogueNodeIdToDomElementMap.get(activeDialogueElement.getAttribute('data-node-id')).classList.add('active');
                }
            }

            function autoResizeTextArea(textarea) {
                if (!textarea || textarea.offsetParent === null) { 
                    return; 
                }
                textarea.style.height = 'auto'; 
                // スクロール高さを取得し、少し余裕を持たせる（例: +2px）
                textarea.style.height = (textarea.scrollHeight + 2) + 'px'; 
            }

            function autoResizeAllTextareas() {
                // セリフはtextareaではないので、textareaのみを対象とする
                document.querySelectorAll('textarea').forEach(autoResizeTextArea);
            }

            newBtn.addEventListener('click', clearAllEditors);

            undoBtn.addEventListener('click', undo);
            redoBtn.addEventListener('click', redo);

            mainEditor.addEventListener('input', () => {
                autoResizeTextArea(mainEditor);
                addToHistory(mainEditor.value); 
                updateUI(); 
            });
            mainEditor.addEventListener('change', () => { 
                updateUIImmediate(); 
            });

            outlineEditor.addEventListener('input', () => {
                autoResizeTextArea(outlineEditor);
            });
            outlineEditor.addEventListener('change', () => { 
                updateUIImmediate(); 
            });

            characterEditor.addEventListener('input', () => {
                autoResizeTextArea(characterEditor);
            });
            characterEditor.addEventListener('change', () => { 
                updateUIImmediate(); 
            });

            addCharacterBtn.addEventListener('click', () => {
                const newCharacterTemplate = `\n\n――――――――――\n*新しいキャラクター（名前：読み方、愛称）男女、歳\n*関係性\n*見た目、身体的特徴、服装\n*性格・裏性格\n*環境・生い立ち`;
                characterEditor.value += newCharacterTemplate;
                autoResizeTextArea(characterEditor);
                characterEditor.focus();
                characterEditor.setSelectionRange(characterEditor.value.length, characterEditor.value.length);
                updateUIImmediate(); 
            });

            addSceneBtn.addEventListener('click', () => {
                const rootElement = currentXmlDoc.querySelector('root');
                if (rootElement) {
                    const newSceneElement = currentXmlDoc.createElement('シーン');
                    const newSceneDescElement = currentXmlDoc.createElement('シーン説明');
                    newSceneDescElement.textContent = '新しいシーン';
                    newSceneElement.appendChild(newSceneDescElement);
                    
                    const newPageElement = currentXmlDoc.createElement('ページ');
                    const newPageDescElement = currentXmlDoc.createElement('ページ説明');
                    newPageDescElement.textContent = '新しいページ';
                    newPageElement.appendChild(newPageDescElement);
                    newSceneElement.appendChild(newPageElement);

                    rootElement.appendChild(newSceneElement);
                    
                    mainEditor.value = serializeXmlToCompactString(currentXmlDoc.documentElement); // カスタムシリアライザを使用
                    addToHistory(mainEditor.value);
                    updateUIImmediate(); 
                    mainEditor.focus();
                } else {
                    alert("XMLの<root>タグが見つかりません。構造を確認してください。");
                }
            });

            function addPageToSpecificScene(sceneElement) { 
                if (sceneElement) {
                    const newPageElement = currentXmlDoc.createElement('ページ');
                    const newPageDescElement = currentXmlDoc.createElement('ページ説明');
                    newPageDescElement.textContent = '新しいページ';
                    newPageElement.appendChild(newPageDescElement);

                    sceneElement.appendChild(newPageElement); 

                    mainEditor.value = serializeXmlToCompactString(currentXmlDoc.documentElement); // カスタムシリアライザを使用
                    addToHistory(mainEditor.value);
                    updateUIImmediate(); 
                    mainEditor.focus();
                } else {
                    alert('選択されたシーンがXML内で見つかりません。');
                }
            }


            toggleButtons.forEach(button => {
                button.addEventListener('click', (e) => {
                    const targetId = e.target.dataset.target;
                    const targetContent = document.getElementById(targetId);
                    setSectionVisibility(targetContent, !targetContent.classList.contains('hidden'));
                });
            });

            // セリフのエクスポート機能
            exportDialogueBtn.addEventListener('click', async () => {
                const pageDialogues = []; // ページごとのセリフを格納する配列

                // ページごとのグループコンテナを取得
                const pageGroupContainers = dialogueContentDiv.querySelectorAll('.serif-page-group-container');
                
                if (pageGroupContainers.length === 0) {
                    alert('エクスポートするセリフがありません。');
                    return;
                }

                // 各ページグループをループして、ページ内のセリフを収集
                pageGroupContainers.forEach(group => {
                    const dialoguesInPage = [];
                    const dialogueElements = group.querySelectorAll('.dialogue-content');
                    dialogueElements.forEach(dialogueEl => {
                        dialoguesInPage.push(dialogueEl.textContent);
                    });
                    // ページ内のセリフを「空白行1つ」で結合して配列に追加
                    pageDialogues.push(dialoguesInPage.join('\n\n'));
                });

                // 各ページのセリフ塊を「空白行2つ」で結合して最終的なテキストを生成
                const allDialogues = pageDialogues.join('\n\n\n');

                // ↓↓↓ ファイル保存処理は元のコードと同じです ↓↓↓

                // ファイル名に日付を含める
                const date = new Date();
                const dateString = `${date.getFullYear()}${(date.getMonth() + 1).toString().padStart(2, '0')}${date.getDate().toString().padStart(2, '0')}_${date.getHours().toString().padStart(2, '0')}${date.getMinutes().toString().padStart(2, '0')}${date.getSeconds().toString().padStart(2, '0')}`;
                const suggestedFileName = `セリフ_${dateString}.txt`;

                try {
                    const fileHandle = await window.showSaveFilePicker({
                        types: [{
                                description: 'Text Files',
                                accept: {
                                    'text/plain': ['.txt'],
                                },
                            },],
                        suggestedName: suggestedFileName
                    });

                    const writable = await fileHandle.createWritable();
                    await writable.write(allDialogues);
                    await writable.close();
                    alert(`セリフをエクスポートしました: ${suggestedFileName}`);
                } catch (err) {
                    if (err.name === 'AbortError') {
                        console.log('Dialogue export was cancelled.');
                    } else {
                        console.error('Error exporting dialogues:', err);
                        alert('セリフのエクスポート中にエラーが発生しました。');
                    }
                }
            });


            loadState();
            // autoResizeAllTextareas(); // これはupdateUIImmediate内でsetTimeoutで呼び出す

            let touchStartX = 0;
            let touchStartY = 0;
            let touchEndX = 0;
            let isSwiping = false;   // 横スワイプ中かどうかのフラグ
            let isScrolling = false; // 縦スクロール中かどうかのフラグ

            columnsWrapper.addEventListener('touchstart', (e) => {
                if (window.innerWidth > 768) return;

                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
                touchEndX = touchStartX; // touchendで使うために初期化
                isSwiping = false;   // フラグをリセット
                isScrolling = false; // フラグをリセット

                columnsWrapper.style.transition = 'none'; 
                currentTranslateX = parseFloat(columnsWrapper.style.transform.replace('translateX(', '').replace('vw)', '') || '0');
                
            }, { passive: true }); // passive: true にしてスクロールの開始を妨げない

            columnsWrapper.addEventListener('touchmove', (e) => {
                if (window.innerWidth > 768 || isScrolling) return;

                const moveX = e.touches[0].clientX;
                const moveY = e.touches[0].clientY;
                const diffX = moveX - touchStartX;
                const diffY = moveY - touchStartY;

                // まだスワイプもスクロールも開始していない場合、方向を判定
                if (!isSwiping && !isScrolling) {
                    // 左右の動きが上下の動きより大きく、かつ一定以上動いた場合、スワイプを開始
                    if (Math.abs(diffX) > Math.abs(diffY) && Math.abs(diffX) > 10) {
                        isSwiping = true;
                    } else if (Math.abs(diffY) > 10) {
                        // 上下の動きが優勢な場合はスクロールとみなし、この後の処理をブロック
                        isScrolling = true;
                        return;
                    }
                }
                
                if (isSwiping) {
                    // スワイプ中と確定したら、ブラウザのデフォルト動作（縦スクロールなど）をキャンセル
                    e.preventDefault();
                    
                    touchEndX = moveX;
                    const transformDiff = (diffX / window.innerWidth) * 100;
                    columnsWrapper.style.transform = `translateX(${currentTranslateX + transformDiff}vw)`;
                }

            }, { passive: false }); // preventDefaultを呼ぶので passive: false にする

            columnsWrapper.addEventListener('touchend', (e) => { 
                if (window.innerWidth > 768) return;

                // 横スワイプ中でなければ、何もしない（縦スクロールなどを妨げない）
                if (!isSwiping) {
                    // 微妙に動いてしまった場合に元の位置に戻す処理
                    columnsWrapper.style.transition = 'transform 0.3s ease-out';
                    showColumn(currentColumnIndex);
                    return;
                }

                const diff = touchEndX - touchStartX;
                // スワイプの閾値を画面幅の25%に設定 (感度を下げる)
                const swipeThreshold = window.innerWidth * 0.25; 

                let newColumnIndex = currentColumnIndex;
                if (diff < -swipeThreshold) { // 左方向へのスワイプ
                    newColumnIndex = Math.min(columns.length - 1, currentColumnIndex + 1);
                } else if (diff > swipeThreshold) { // 右方向へのスワイプ
                    newColumnIndex = Math.max(0, currentColumnIndex - 1);
                }
                // 閾値以下の場合は元の位置に戻る（newColumnIndexは変更されない）
                
                columnsWrapper.style.transition = 'transform 0.3s ease-out';
                showColumn(newColumnIndex);
                
                // 最後にフラグをリセット
                isSwiping = false;
                isScrolling = false;
            }, { passive: true });

            window.addEventListener('resize', () => {
                showColumn(currentColumnIndex); 
                autoResizeAllTextareas(); 
            });

            showColumn(currentColumnIndex);
        });

    </script>
</body>
</html>

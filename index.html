<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>漫画ネームエディタ.ver1.4</title>

    <!-- PWA & Favicon -->
    <link rel="manifest" href="/MNE/manifest.json">
    <link rel="apple-touch-icon" href="/MNE/icon192.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/MNE/icon180.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/MNE/icon32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/MNE/icon16.png">

    <!-- Viewport -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    
    <style>
        /* 基本レイアウト */
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background-color: #e0e0e0;
        }
        body {
            display: flex;
            flex-direction: column;
        }
        .main-container {
            flex-grow: 1;
            display: flex;
            overflow: hidden; /* ★重要: ここでコンテナの高さを固定 */
        }
        .columns-wrapper {
            display: flex;
            width: 100%;
            height: 100%;
            overflow-x: auto;
            transition: none;
        }
        .column {
            width: 25vw;
            flex-shrink: 0;
            background-color: #fff;
            display: flex;
            flex-direction: column;
            border-right: 1px solid #eee;
            box-sizing: border-box;
            height: 100%;
            overflow: hidden;
        }
        .column:last-child {
            border-right: none;
        }
        .column-header {
            background-color: #34495e;
            color: white;
            padding: 10px;
            font-weight: bold;
            flex-shrink: 0;
            position: sticky;
            top: 0;
            z-index: 10;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .column-header .header-title { flex-shrink: 0; margin-right: auto; }
        .column-header .controls { display: flex; gap: 5px; flex-wrap: wrap; justify-content: flex-end; align-items: center; }
        .column-header .controls button {
            background-color: #6c757d; color: white; padding: 5px 10px; border: none;
            border-radius: 3px; cursor: pointer; font-size: 13px; margin-left: 5px;
        }
        .column-header .controls button:hover { background-color: #5a6268; }
        .column-header .controls button:disabled { background-color: #999; cursor: not-allowed; }
        
        .column-content { flex-grow: 1; overflow-y: auto; padding: 10px; display: flex; flex-direction: column; gap: 10px; min-height: 0; }

        /* テキストエリア共通 */
        textarea {
            width: 100%; height: auto; padding: 8px; border: 1px solid #ddd; border-radius: 4px;
            font-family: 'Meiryo', 'Hiragino Kaku Gothic ProN', 'BIZ UDPGothic', sans-serif;
            font-size: 1em; line-height: 1.6; resize: none; box-sizing: border-box; min-height: 50px; overflow: hidden;
        }
        .main-textarea, .outline-textarea { resize: vertical; }
        .character-textarea { min-height: 70vh; resize: vertical; overflow-y: auto; }

        /* 動的生成要素 */
        .scene-item-container { border: 1px solid #ccc; margin-bottom: 10px; border-radius: 5px; box-shadow: 0 1px 3px rgba(0,0,0,0.05); display: flex; flex-direction: column; cursor: pointer; }
        .scene-color-0 { background-color: #e0f7fa; } .scene-color-1 { background-color: #f0f4c3; } .scene-color-2 { background-color: #ffe0b2; } .scene-color-3 { background-color: #e1bee7; } .scene-color-4 { background-color: #b3e5fc; }
        .page-item-container { border: 1px solid #ccc; margin-bottom: 5px; border-radius: 5px; box-shadow: 0 1px 3px rgba(0,0,0,0.05); cursor: pointer; }
        .serif-page-group-container { border: 1px solid #dcdcdc; border-radius: 5px; margin-bottom: 15px; padding: 10px; padding-top: 0; background-color: #fffbf0; box-shadow: 0 1px 3px rgba(0,0,0,0.05); }
        .dialogue-content { margin-bottom: 8px; background-color: white; border: 1px solid #ddd; border-left: 3px solid #f9ab00; padding: 5px; border-radius: 3px; white-space: pre-wrap; word-wrap: break-word; font-size: 0.95em; line-height: 1.6; cursor: pointer; }
        .scene-item-header, .page-item-header { display: flex; justify-content: space-between; align-items: center; padding: 5px 10px; }
        .scene-title-badge, .page-title-badge { background-color: #007bff; color: white; padding: 3px 8px; border-radius: 4px; font-weight: bold; }
        .delete-scene-btn, .delete-page-btn { background-color: #dc3545; color: white; border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer; font-size: 0.8em; }
        .delete-scene-btn:hover, .delete-page-btn:hover { background-color: #c82333; }
        .add-page-to-scene-btn {
            background-color: #34495e; color: white; padding: 5px 10px; border: none; border-radius: 3px; cursor: pointer; font-size: 0.9em;
            width: calc(100% - 20px); box-sizing: border-box; margin: 10px; text-align: center;
        }
        .add-page-to-scene-btn:hover { background-color: #2c3e50; }

        /* セクション折りたたみ */
        .section-container { border: 1px solid #ccc; border-radius: 5px; margin-bottom: 10px; box-shadow: 0 1px 3px rgba(0,0,0,0.05); background-color: #f8f8f8; overflow: hidden; }
        .section-header { background-color: #f0f0f0; padding: 8px 10px; border-bottom: 1px solid #eee; display: flex; justify-content: space-between; align-items: center; font-weight: bold; cursor: pointer; }
        .section-header h3 { margin: 0; font-size: 1em; color: #333; flex-grow: 1; }
        .toggle-btn, .add-character-btn { background-color: #6c757d; color: white; padding: 4px 8px; border: none; border-radius: 3px; cursor: pointer; font-size: 0.8em; margin-left: 5px; }
        .toggle-btn:hover, .add-character-btn:hover { background-color: #5a6268; }
        .section-content { padding: 10px; }
        .section-content.hidden { display: none; }

        /* アクティブ要素のハイライト */
        .scene-item-container.active, .page-item-container.active, .dialogue-content.active { box-shadow: 0 0 8px 3px rgba(0, 123, 255, 0.5); border-color: #007bff; }

        /* タブバー */
        .tab-bar { display: none; background: white; border-top: 1px solid #ddd; flex-shrink: 0; height: 60px; box-shadow: 0 -2px 4px rgba(0,0,0,0.05); }
        .tab-item { flex: 1; padding: 8px 0; display: flex; flex-direction: column; justify-content: center; align-items: center; gap: 2px; cursor: pointer; position: relative; color: #666; }
        .tab-item.active { color: #1a73e8; }
        .tab-item.active::before { content: ''; position: absolute; top: 0; left: 10%; right: 10%; height: 3px; background: #1a73e8; border-radius: 0 0 3px 3px; }
        .tab-icon { font-size: 22px; }
        .tab-label { font-size: 10px; }

        /* --- スマートフォン表示用のスタイル --- */
        body.mobile-view .tab-bar { display: flex; }
        body.mobile-view .columns-wrapper { scroll-snap-type: x mandatory; -webkit-overflow-scrolling: touch; }
        body.mobile-view .columns-wrapper::-webkit-scrollbar { display: none; }
        body.mobile-view .columns-wrapper { -ms-overflow-style: none; scrollbar-width: none; }
        body.mobile-view .column { width: 100vw; border-right: none; scroll-snap-align: start; }
        body.mobile-view .column-header { flex-direction: column; align-items: flex-start; padding: 8px; }
        body.mobile-view .column-header .header-title { margin-right: 0; margin-bottom: 5px; }
        body.mobile-view .column-header .controls { width: 100%; justify-content: space-around; }
        body.mobile-view .column-header .controls button { flex-grow: 1; margin-left: 0; padding: 8px 5px; font-size: 1em; }
        body.mobile-view .scene-column .column-header,
        body.mobile-view .serif-column .column-header { flex-direction: row; justify-content: space-between; align-items: center; }
        body.mobile-view .scene-column .column-header .header-title,
        body.mobile-view .serif-column .column-header .header-title { margin-bottom: 0; }
        body.mobile-view .scene-column .column-header .controls,
        body.mobile-view .serif-column .column-header .controls { width: auto; }
        body.mobile-view .scene-column .column-header .controls button,
        body.mobile-view .serif-column .column-header .controls button { flex-grow: 0; padding: 6px 12px; }

        @media (max-width: 480px) {
            .column-header .controls button { font-size: 0.9em; padding: 6px 3px; }
            .section-header h3 { font-size: 0.9em; }
            .toggle-btn, .add-character-btn { font-size: 0.7em; padding: 3px 6px; }
            textarea { font-size: 0.9em; }
        }
    </style>
</head>
<body>
    <div class="main-container">
        <div class="columns-wrapper" id="columnsWrapper">
            <div class="column main-column" data-column-id="main">
                <div class="column-header">
                    <span class="header-title">メイン</span>
                    <div class="controls">
                        <button id="viewModeBtn" title="表示モードを切り替えます">表示切替</button>
                        <button id="newBtn">新規</button>
                        <button id="openBtn">開く</button>
                        <input type="file" id="fileInput" style="display: none;">
                        <button id="saveBtn">保存</button>
                        <button id="saveAsBtn">別名保存</button>
                        <button id="undoBtn">↶</button>
                        <button id="redoBtn">↷</button>
                    </div>
                </div>
                <div class="column-content">
                    <div class="section-container" id="outlineSection">
                        <div class="section-header"><h3 >アウトライン</h3><button class="toggle-btn" data-target="outlineContent">隠す</button></div>
                        <div class="section-content" id="outlineContent"><textarea id="outlineEditor" class="outline-textarea" placeholder="ここに物語のアウトラインを記述してください。"></textarea></div>
                    </div>
                    <div class="section-container" id="characterSection">
                        <div class="section-header"><h3>キャラクター</h3><div class="controls"><button class="add-character-btn" id="addCharacterBtn">追加</button><button class="toggle-btn" data-target="characterContent">隠す</button></div></div>
                        <div class="section-content" id="characterContent"><textarea id="characterEditor" class="character-textarea"></textarea></div>
                    </div>
                    <div class="section-container" id="mainEditorSection">
                        <div class="section-header"><h3>ネーム本体 (XML)</h3><button class="toggle-btn" data-target="mainEditorContent">隠す</button></div>
                        <div class="section-content" id="mainEditorContent"><textarea id="mainEditor" class="main-textarea" placeholder="XML形式でネームを記述してください。例：<root><シーン><シーン説明>...</シーン説明><ページ>...</ページ></シーン></root>"></textarea></div>
                    </div>
                </div>
            </div>
            <div class="column scene-column" data-column-id="scene">
                <div class="column-header"><span class="header-title">シーン</span><div class="controls"><button id="addSceneBtn">シーン追加</button></div></div>
                <div class="column-content" id="sceneContent"></div>
            </div>
            <div class="column page-column" data-column-id="page">
                <div class="column-header"><span class="header-title">ページ</span></div>
                <div class="column-content" id="pageContent"></div>
            </div>
            <div class="column serif-column" data-column-id="serif">
                <div class="column-header"><span class="header-title">セリフ</span><div class="controls"><button id="exportDialogueBtn">エクスポート</button></div></div>
                <div class="column-content" id="dialogueContent"></div>
            </div>
        </div>
    </div>
    <div class="tab-bar">
        <div class="tab-item active" data-page="0"><span class="tab-icon">📝</span><span class="tab-label">メイン</span></div>
        <div class="tab-item" data-page="1"><span class="tab-icon">🎬</span><span class="tab-label">シーン</span></div>
        <div class="tab-item" data-page="2"><span class="tab-icon">📄</span><span class="tab-label">ページ</span></div>
        <div class="tab-item" data-page="3"><span class="tab-icon">💬</span><span class="tab-label">セリフ</span></div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM要素の取得 ---
            const bodyElement = document.body;
            const columnsWrapper = document.getElementById('columnsWrapper');
            const columns = Array.from(document.querySelectorAll('.column'));
            const viewModeBtn = document.getElementById('viewModeBtn');
            const tabItems = document.querySelectorAll('.tab-item');
            const mainEditor = document.getElementById('mainEditor');
            const outlineEditor = document.getElementById('outlineEditor');
            const characterEditor = document.getElementById('characterEditor');
            const sceneContentDiv = document.getElementById('sceneContent');
            const pageContentDiv = document.getElementById('pageContent');
            const dialogueContentDiv = document.getElementById('dialogueContent');
            const outlineContentDiv = document.getElementById('outlineContent');
            const characterContentDiv = document.getElementById('characterContent');
            const mainEditorContentDiv = document.getElementById('mainEditorContent');

            // --- 状態管理変数 ---
            let currentColumnIndex = 0;
            let currentFileName = '新規ネーム.txt';
            let currentFileHandle = null;
            let history = [''];
            let historyIndex = 0;
            const MAX_HISTORY = 100;
            let updateTimeout;
            const DEBOUNCE_DELAY = 300;
            let currentXmlDoc = null;
            const xmlParser = new DOMParser();
            let nodeIdCounter = 0;
            const sceneNodeIdToDomElementMap = new Map();
            const pageNodeIdToDomElementMap = new Map();
            const sceneNodeIdToFirstPageDomElementMap = new Map();
            const dialogueNodeIdToDomElementMap = new Map();
            let activeElement = { type: null, element: null };
            let scrollTimeout;

            // --- UI制御 ---
            function showColumn(index, behavior = 'smooth') {
                if (index < 0 || index >= columns.length) return;
                currentColumnIndex = index;
                const targetScrollLeft = columns[index].offsetLeft;
                columnsWrapper.scrollTo({ left: targetScrollLeft, behavior: behavior });
                if (document.body.classList.contains('mobile-view')) updateActiveTab();
            }

            function updateActiveTab() {
                tabItems.forEach(tab => tab.classList.remove('active'));
                const activeTab = document.querySelector(`.tab-item[data-page='${currentColumnIndex}']`);
                if (activeTab) activeTab.classList.add('active');
            }

            // --- 表示モード切替 ---
            function applyViewMode() {
                const override = localStorage.getItem('viewModeOverride');
                const isMobile = (override === 'mobile') || (override === null && window.innerWidth <= 768);
                bodyElement.classList.toggle('mobile-view', isMobile);
                viewModeBtn.textContent = override ? '自動に戻す' : '表示切替';
                viewModeBtn.title = override ? 'ウィンドウ幅に応じた自動表示に戻します' : '現在の表示をPC⇔スマホで切り替えます';
                showColumn(currentColumnIndex, 'auto');
                autoResizeAllTextareas();
            }

            // --- Undo/Redo & 履歴管理 ---
            function undo() {
                if (historyIndex > 0) {
                    historyIndex--;
                    mainEditor.value = history[historyIndex];
                    updateUIImmediate();
                }
            }
            function redo() {
                if (historyIndex < history.length - 1) {
                    historyIndex++;
                    mainEditor.value = history[historyIndex];
                    updateUIImmediate();
                }
            }
            function updateUndoRedoButtons() {
                document.getElementById('undoBtn').disabled = historyIndex === 0;
                document.getElementById('redoBtn').disabled = historyIndex === history.length - 1;
            }
            function addToHistory(content) {
                if (history.length > 0 && history[historyIndex] === content) return;
                history.splice(historyIndex + 1);
                history.push(content);
                if (history.length > MAX_HISTORY) history.shift();
                historyIndex = history.length - 1;
                updateUndoRedoButtons();
            }

            // --- データ永続化 (localStorage) ---
            function saveState() {
                const state = {
                    outlineContent: outlineEditor.value,
                    characterContent: characterEditor.value,
                    mainContent: mainEditor.value,
                    fileName: currentFileName,
                    history: history,
                    historyIndex: historyIndex,
                    outlineHidden: outlineContentDiv.classList.contains('hidden'),
                    characterHidden: characterContentDiv.classList.contains('hidden'),
                    mainEditorHidden: mainEditorContentDiv.classList.contains('hidden'),
                    currentColumnIndex: currentColumnIndex
                };
                localStorage.setItem('comicNameEditorState', JSON.stringify(state));
            }
            function loadState() {
                const savedState = localStorage.getItem('comicNameEditorState');
                if (savedState) {
                    const state = JSON.parse(savedState);
                    Object.assign(outlineEditor, { value: state.outlineContent || '' });
                    Object.assign(characterEditor, { value: state.characterContent || '' });
                    Object.assign(mainEditor, { value: state.mainContent || '' });
                    currentFileName = state.fileName || '新規ネーム.txt';
                    history = state.history || [''];
                    historyIndex = state.historyIndex || 0;
                    setSectionVisibility(outlineContentDiv, state.outlineHidden || false);
                    setSectionVisibility(characterContentDiv, state.characterHidden || false);
                    setSectionVisibility(mainEditorContentDiv, state.mainEditorHidden || false);
                    currentColumnIndex = state.currentColumnIndex !== undefined ? state.currentColumnIndex : 0;
                } else {
                    clearAllEditors(false);
                }
                updateUIImmediate();
                applyViewMode();
            }
            function setSectionVisibility(contentDiv, isHidden) {
                const toggleBtn = contentDiv.previousElementSibling.querySelector('.toggle-btn');
                contentDiv.classList.toggle('hidden', isHidden);
                if (toggleBtn) toggleBtn.textContent = isHidden ? '開く' : '隠す';
                if (!isHidden) autoResizeAllTextareas();
            }
            
            // --- ファイル操作 ---
            function clearAllEditors(showAlert = true) {
                outlineEditor.value = '';
                characterEditor.value = `*主人公（名前：読み方、愛称）男女、歳\n*関係性\n*見た目、身体的特徴、服装\n*性格・裏性格\n*環境・生い立ち`;
                mainEditor.value = `<root><シーン><シーン説明>新しいシーン</シーン説明><ページ><ページ説明>新しいページ</ページ説明></ページ></シーン></root>`;
                currentFileName = '新規ネーム.txt';
                currentFileHandle = null;
                history = [mainEditor.value];
                historyIndex = 0;
                localStorage.removeItem('comicNameEditorState');
                [outlineContentDiv, characterContentDiv, mainEditorContentDiv].forEach(el => setSectionVisibility(el, false));
                currentColumnIndex = 0;
                updateUIImmediate();
                if (showAlert) alert('新しいネームを開始しました。');
            }
            async function openFile() {
                try {
                    const [fileHandle] = await window.showOpenFilePicker({ types: [{ description: 'Text Files', accept: { 'text/plain': ['.txt'] } }] });
                    const file = await fileHandle.getFile();
                    const text = await file.text();
                    extractAndSetSeparateContents(text);
                    currentFileName = file.name;
                    currentFileHandle = fileHandle;
                    history = [mainEditor.value];
                    historyIndex = 0;
                    updateUIImmediate();
                } catch (err) { if (err.name !== 'AbortError') console.error('Error opening file:', err); }
            }
            async function saveFile(saveAs = false) {
                const content = `[アウトライン:]\n${outlineEditor.value}\n\n[キャラクター:]\n${characterEditor.value}\n\n[ネーム本体(XML):]\n${mainEditor.value}\n\n`;
                try {
                    let handleToSave = currentFileHandle;
                    if (saveAs || !handleToSave) {
                        handleToSave = await window.showSaveFilePicker({ types: [{ description: 'Text Files', accept: { 'text/plain': ['.txt'] } }], suggestedName: currentFileName });
                    }
                    const writable = await handleToSave.createWritable();
                    await writable.write(content);
                    await writable.close();
                    currentFileHandle = handleToSave;
                    currentFileName = handleToSave.name;
                    alert(`ファイルを保存しました: ${currentFileName}`);
                } catch (err) { if (err.name !== 'AbortError') console.error('Error saving file:', err); }
            }
            function handleDrop(e) {
                e.preventDefault();
                bodyElement.classList.remove('drag-over');
                const file = e.dataTransfer.files[0];
                if (file && file.type === 'text/plain') {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        extractAndSetSeparateContents(event.target.result);
                        currentFileName = file.name; currentFileHandle = null; history = [mainEditor.value]; historyIndex = 0;
                        updateUIImmediate();
                    };
                    reader.readAsText(file);
                }
            }
            function extractAndSetSeparateContents(fullText) {
                const extracted = { outline: '', character: '', main: '' };
                const outlineMatch = fullText.match(/\[アウトライン:\]\n([\s\S]*?)(?=\n*\[(キャラクター|ネーム本体\(XML\)):\]|$)/);
                const characterMatch = fullText.match(/\[キャラクター:\]\n([\s\S]*?)(?=\n*\[ネーム本体\(XML\):\]|$)/);
                const mainXmlMatch = fullText.match(/\[ネーム本体\(XML\):\]\n([\s\S]*?)$/);
                extracted.outline = outlineMatch ? outlineMatch[1].trim() : '';
                extracted.character = characterMatch ? characterMatch[1].trim() : '';
                extracted.main = mainXmlMatch ? mainXmlMatch[1].trim() : (!outlineMatch && !characterMatch ? fullText : '');
                outlineEditor.value = extracted.outline; characterEditor.value = extracted.character; mainEditor.value = extracted.main;
            }

            // --- UI更新 & パース処理 ---
            function updateUI() {
                clearTimeout(updateTimeout);
                updateTimeout = setTimeout(() => { updateUIImmediate(false); saveState(); }, DEBOUNCE_DELAY);
            }
            function updateUIImmediate(save = true) {
                updateUndoRedoButtons();
                syncColumnsFromMainEditor();
                setTimeout(autoResizeAllTextareas, 50);
                if (save) saveState();
            }
            function autoResizeAllTextareas() {
                document.querySelectorAll('textarea').forEach(textarea => {
                    if (!textarea || !textarea.offsetParent) return;
                    textarea.style.height = 'auto';
                    textarea.style.height = (textarea.scrollHeight + 2) + 'px';
                });
            }

            function serializeXml(node) {
                if (!node) return '';
                if (node.nodeType === Node.ELEMENT_NODE) {
                    let xml = `<${node.tagName}>`;
                    for (let child of node.childNodes) xml += serializeXml(child);
                    xml += `</${node.tagName}>`;
                    return xml;
                } else if (node.nodeType === Node.TEXT_NODE) {
                    return node.textContent.replace(/&/g, '&').replace(/</g, '<').replace(/>/g, '>').replace(/"/g, '"').replace(/'/g, ''');
                } return '';
            }
            
            function syncColumnsFromMainEditor() {
                [sceneNodeIdToDomElementMap, pageNodeIdToDomElementMap, sceneNodeIdToFirstPageDomElementMap, dialogueNodeIdToDomElementMap].forEach(m => m.clear());
                nodeIdCounter = 0;

                let textToParse = mainEditor.value.trim() || '<root></root>';
                if (!textToParse.startsWith('<root>')) textToParse = `<root>${textToParse}</root>`;
                
                currentXmlDoc = xmlParser.parseFromString(textToParse, "application/xml");
                const parserError = currentXmlDoc.querySelector('parsererror');
                if (parserError) {
                    [sceneContentDiv, pageContentDiv, dialogueContentDiv].forEach(d => d.innerHTML = '<p style="color: red;">XMLパースエラー</p>'); return;
                }
                
                [sceneContentDiv, pageContentDiv, dialogueContentDiv].forEach(d => d.innerHTML = '');
                const scenes = currentXmlDoc.querySelectorAll('シーン');
                if (scenes.length === 0) {
                    [sceneContentDiv, pageContentDiv, dialogueContentDiv].forEach(d => d.innerHTML = '<p>シーンがありません。</p>');
                }

                let globalPageIndex = 1;
                scenes.forEach((sceneElement, sceneIndex) => {
                    renderSceneItem(sceneElement, sceneIndex);
                    const pagesInScene = sceneElement.querySelectorAll('ページ');
                    pagesInScene.forEach((pageElement, pageIndexInScene) => {
                        renderPageItem(pageElement, sceneIndex, pageIndexInScene, globalPageIndex);
                        const dialoguesInPage = pageElement.querySelectorAll('セリフ');
                        if (dialoguesInPage.length > 0) renderDialogueGroup(dialoguesInPage, sceneIndex, pageIndexInScene, globalPageIndex);
                        globalPageIndex++;
                    });
                    const addPageButton = document.createElement('button');
                    addPageButton.className = 'add-page-to-scene-btn';
                    addPageButton.textContent = `「シーン${sceneIndex + 1}」にページを追加`;
                    addPageButton.onclick = () => addPageToSpecificScene(sceneElement);
                    pageContentDiv.appendChild(addPageButton);
                });
                highlightActiveElements();
            }

            // --- 動的要素レンダリング ---
            function renderSceneItem(sceneElement, sceneIndex) {
                const nodeId = `node-${nodeIdCounter++}`;
                const container = document.createElement('div');
                container.className = `scene-item-container scene-color-${sceneIndex % 5}`;
                container.dataset.nodeId = nodeId;
                container.onclick = () => {
                    setActiveElement(container, 'scene');
                    const firstPageElement = sceneNodeIdToFirstPageDomElementMap.get(nodeId);
                    showColumn(firstPageElement ? 2 : 1);
                    if (firstPageElement) firstPageElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
                };
                const header = document.createElement('div');
                header.className = 'scene-item-header';
                header.innerHTML = `<span class="scene-title-badge">シーン${sceneIndex + 1}</span><button class="delete-scene-btn">削除</button>`;
                header.querySelector('.delete-scene-btn').onclick = (e) => { e.stopPropagation(); deleteScene(sceneElement); };
                const textarea = document.createElement('textarea');
                textarea.value = sceneElement.querySelector('シーン説明')?.textContent || '';
                textarea.placeholder = 'シーンの説明';
                textarea.oninput = (e) => { autoResizeTextArea(e.target); updateSceneContentInXml(sceneIndex, e.target.value); };
                textarea.onchange = () => updateUIImmediate();
                container.append(header, textarea);
                sceneContentDiv.appendChild(container);
                sceneNodeIdToDomElementMap.set(nodeId, container);
            }

            function renderPageItem(pageElement, sceneIndex, pageIndexInScene, globalPageIndex) {
                const nodeId = `node-${nodeIdCounter++}`;
                const parentSceneNodeId = [...sceneNodeIdToDomElementMap.keys()].find(key => sceneNodeIdToDomElementMap.get(key).dataset.sceneIndex == sceneIndex);
                const container = document.createElement('div');
                container.className = `page-item-container scene-color-${sceneIndex % 5}`;
                container.dataset.nodeId = nodeId; container.dataset.parentSceneId = parentSceneNodeId;
                container.onclick = () => { setActiveElement(container, 'page'); showColumn(2); };
                const header = document.createElement('div');
                header.className = 'page-item-header';
                header.innerHTML = `<span class="page-title-badge">ページ${globalPageIndex}</span><button class="delete-page-btn">削除</button>`;
                header.querySelector('.delete-page-btn').onclick = (e) => { e.stopPropagation(); deletePage(pageElement); };
                const textarea = document.createElement('textarea');
                textarea.value = Array.from(pageElement.childNodes).map(child => child.nodeName === 'ページ説明' ? child.textContent : (child.nodeName === 'セリフ' ? `「${child.textContent}」` : '')).join('');
                textarea.placeholder = 'ページの説明や「セリフ」';
                textarea.oninput = (e) => { autoResizeTextArea(e.target); updatePageContentInXml(sceneIndex, pageIndexInScene, e.target.value); };
                textarea.onchange = () => updateUIImmediate();
                container.append(header, textarea);
                pageContentDiv.appendChild(container);
                pageNodeIdToDomElementMap.set(nodeId, container);
                if (!sceneNodeIdToFirstPageDomElementMap.has(parentSceneNodeId)) sceneNodeIdToFirstPageDomElementMap.set(parentSceneNodeId, container);
            }

            function renderDialogueGroup(dialoguesInPage, sceneIndex, pageIndexInScene, globalPageIndex) {
                const parentPageNodeId = [...pageNodeIdToDomElementMap.keys()].find(key => pageNodeIdToDomElementMap.get(key).dataset.sceneIndex == sceneIndex && pageNodeIdToDomElementMap.get(key).dataset.pageIndexInScene == pageIndexInScene);
                const groupContainer = document.createElement('div');
                groupContainer.className = 'serif-page-group-container';
                groupContainer.innerHTML = `<p style="font-weight: bold; font-size: 0.9em; margin-bottom: 5px; padding-bottom: 5px; border-bottom: 1px dashed #ccc;">ページ ${globalPageIndex}</p>`;
                dialoguesInPage.forEach((dialogueElement, dialogueIndexInPage) => {
                    const nodeId = `node-${nodeIdCounter++}`;
                    const dialogueDiv = document.createElement('div');
                    dialogueDiv.className = 'dialogue-content';
                    dialogueDiv.dataset.nodeId = nodeId; dialogueDiv.dataset.parentPageId = parentPageNodeId;
                    dialogueDiv.textContent = dialogueElement.textContent;
                    dialogueDiv.onclick = () => { setActiveElement(dialogueDiv, 'dialogue'); showColumn(3); };
                    groupContainer.appendChild(dialogueDiv);
                    dialogueNodeIdToDomElementMap.set(nodeId, dialogueDiv);
                });
                dialogueContentDiv.appendChild(groupContainer);
            }
            
            function highlightActiveElements() {
                document.querySelectorAll('.active').forEach(el => el.classList.remove('active'));
                if (activeElement.element) activeElement.element.classList.add('active');
            }

            function setActiveElement(element, type) {
                activeElement = { element, type };
                highlightActiveElements();
            }

            // --- XML更新 ---
            function updateXmlAndUI(updateFn) {
                updateFn();
                mainEditor.value = serializeXml(currentXmlDoc.documentElement);
                addToHistory(mainEditor.value);
                updateUIImmediate();
            }
            function updateSceneContentInXml(sceneIndex, newText) {
                const sceneEl = currentXmlDoc.querySelectorAll('シーン')[sceneIndex];
                if (sceneEl) {
                    let desc = sceneEl.querySelector('シーン説明');
                    if (!desc) { desc = currentXmlDoc.createElement('シーン説明'); sceneEl.prepend(desc); }
                    desc.textContent = newText;
                    mainEditor.value = serializeXml(currentXmlDoc.documentElement);
                }
            }
            function updatePageContentInXml(sceneIndex, pageIndexInScene, fullPageText) {
                const pageEl = currentXmlDoc.querySelectorAll('シーン')[sceneIndex]?.querySelectorAll('ページ')[pageIndexInScene];
                if (pageEl) {
                    while (pageEl.firstChild) pageEl.firstChild.remove();
                    const regex = /「([\s\S]*?)」/g;
                    let lastIndex = 0, match;
                    while ((match = regex.exec(fullPageText))) {
                        if (match.index > lastIndex) pageEl.append(Object.assign(currentXmlDoc.createElement('ページ説明'), { textContent: fullPageText.substring(lastIndex, match.index) }));
                        pageEl.append(Object.assign(currentXmlDoc.createElement('セリフ'), { textContent: match[1] }));
                        lastIndex = regex.lastIndex;
                    }
                    if (lastIndex < fullPageText.length) pageEl.append(Object.assign(currentXmlDoc.createElement('ページ説明'), { textContent: fullPageText.substring(lastIndex) }));
                    mainEditor.value = serializeXml(currentXmlDoc.documentElement);
                }
            }
            function addScene() { updateXmlAndUI(() => currentXmlDoc.querySelector('root')?.append(Object.assign(currentXmlDoc.createElement('シーン'), { innerHTML: '<シーン説明>新しいシーン</シーン説明>' }))); }
            function addPageToSpecificScene(sceneElement) { updateXmlAndUI(() => sceneElement.append(Object.assign(currentXmlDoc.createElement('ページ'), { innerHTML: '<ページ説明>新しいページ</ページ説明>' }))); }
            function deleteScene(sceneElement) { if (confirm('このシーンを削除しますか？')) updateXmlAndUI(() => sceneElement.remove()); }
            function deletePage(pageElement) { if (confirm('このページを削除しますか？')) updateXmlAndUI(() => pageElement.remove()); }
            function exportDialogues() {
                const allDialogues = Array.from(dialogueContentDiv.querySelectorAll('.serif-page-group-container')).map(group => Array.from(group.querySelectorAll('.dialogue-content')).map(d => d.textContent).join('\n\n')).join('\n\n\n');
                if (!allDialogues) return alert('エクスポートするセリフがありません。');
                const blob = new Blob([allDialogues], { type: 'text/plain' });
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = `セリフ_${new Date().toISOString().slice(0,19).replace(/[-T:]/g,"")}.txt`;
                a.click();
                URL.revokeObjectURL(a.href);
            }

            // --- イベントリスナー設定 ---
            document.getElementById('newBtn').onclick = () => clearAllEditors();
            document.getElementById('openBtn').onclick = openFile;
            document.getElementById('saveBtn').onclick = () => saveFile(false);
            document.getElementById('saveAsBtn').onclick = () => saveFile(true);
            document.getElementById('undoBtn').onclick = undo;
            document.getElementById('redoBtn').onclick = redo;
            document.getElementById('addSceneBtn').onclick = addScene;
            document.getElementById('exportDialogueBtn').onclick = exportDialogues;
            document.getElementById('addCharacterBtn').onclick = () => { characterEditor.value += `\n\n――――――――――\n*新しいキャラクター`; autoResizeTextArea(characterEditor); };
            mainEditor.oninput = () => { autoResizeTextArea(mainEditor); updateUI(); };
            mainEditor.onchange = () => { addToHistory(mainEditor.value); updateUIImmediate(); };
            outlineEditor.onchange = saveState; characterEditor.onchange = saveState;
            document.querySelectorAll('.toggle-btn').forEach(btn => btn.onclick = (e) => setSectionVisibility(document.getElementById(e.target.dataset.target), !document.getElementById(e.target.dataset.target).classList.contains('hidden')));
            bodyElement.ondragover = (e) => { e.preventDefault(); bodyElement.classList.add('drag-over'); };
            bodyElement.ondragleave = () => bodyElement.classList.remove('drag-over');
            bodyElement.ondrop = handleDrop;
            
            tabItems.forEach(tab => tab.addEventListener('click', () => showColumn(parseInt(tab.dataset.page, 10))));

            columnsWrapper.addEventListener('scroll', () => {
                if (!bodyElement.classList.contains('mobile-view')) return;
                clearTimeout(scrollTimeout);
                scrollTimeout = setTimeout(() => {
                    const newIndex = Math.round(columnsWrapper.scrollLeft / columnsWrapper.offsetWidth);
                    if (newIndex !== currentColumnIndex) { currentColumnIndex = newIndex; updateActiveTab(); saveState(); }
                }, 150);
            });
            
            // --- 初期化 ---
            function adjustHeight() { bodyElement.style.height = `${window.innerHeight}px`; }
            window.addEventListener('resize', () => { adjustHeight(); applyViewMode(); });
            window.addEventListener('orientationchange', adjustHeight);
            
            if ('serviceWorker' in navigator) {
                window.addEventListener('load', () => navigator.serviceWorker.register('/MNE/sw.js').catch(err => console.log('SW reg failed: ', err)));
            }

            adjustHeight();
            loadState();
        });
    </script>
</body>
</html>

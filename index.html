<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>漫画ネームエディタ</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            height: 100vh; /* ビューポートの高さに合わせる */
            display: flex;
            flex-direction: column;
            background-color: #e0e0e0;
            overflow: hidden; /* 全体スクロールは禁止 (カラムスライドのため) */
        }

        /* グローバルヘッダーは不要なため削除 */
        /* .global-header { ... } を削除 */

        /* PC版のデフォルトスタイル（4カラム表示） */
        .columns-wrapper { /* カラム全体を包むラッパー */
            flex-grow: 1;
            display: flex;
            width: 100%; /* PCでは100%幅 */
            padding-top: 0; /* グローバルヘッダーを削除したので0 */
            padding-bottom: 0; /* フッターナビを削除したので0 */
            box-sizing: border-box;
            overflow-x: auto; /* PCでは横スクロールを許可 */
            transition: none; /* PCではスライドアニメーションなし */
        }

        .column {
            width: 25vw; /* 各カラムの幅をビューポートの25%に */
            flex-shrink: 0; /* カラムが縮まないように */
            background-color: #fff;
            display: flex;
            flex-direction: column;
            border-right: 1px solid #eee; /* 各カラムの右側に境界線 */
            box-sizing: border-box;
            overflow: hidden; /* カラム自体はスクロールバーを持たない */
        }
        .column:last-child {
            border-right: none; /* 最後のカラムには境界線不要 */
        }


        /* 各カラムヘッダ内のボタンのスタイルを定義 */
        .column-header {
            background-color: #34495e;
            color: white;
            padding: 10px;
            font-weight: bold;
            text-align: center;
            flex-shrink: 0;
            position: sticky; /* カラム内でスクロールしても固定 */
            top: 0;
            z-index: 10;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .column-header .header-title {
            flex-shrink: 0;
            margin-right: auto;
        }

        .column-header .controls {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
            justify-content: flex-end;
            align-items: center;
        }

        .column-header .controls button {
            background-color: #6c757d;
            color: white;
            padding: 5px 10px;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 13px;
            transition: background-color 0.2s;
            margin-left: 5px;
        }

        .column-header .controls button#undoBtn,
        .column-header .controls button#redoBtn {
            background-color: #5a6268;
        }

        .column-header .controls button:hover {
            background-color: #5a6268;
        }
        
        .column-header .controls button#undoBtn:hover,
        .column-header .controls button#redoBtn:hover {
            background-color: #4a5157;
        }


        .column-header .controls button:disabled {
            background-color: #999;
            cursor: not-allowed;
        }

        .column-content {
            flex-grow: 1;
            overflow-y: auto; /* この領域でスクロールする */
            padding: 10px;
            /*display: flex;*/
            flex-direction: column;
            gap: 10px;
        }

        textarea {
            width: 100%;
            height: auto; /* 自動リサイズのためにautoに */
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: 'Meiryo', 'Hiragino Kaku Gothic ProN', 'BIZ UDPGothic', sans-serif;
            font-size: 1em;
            line-height: 1.6;
            resize: none; /* デフォルトはなし */
            box-sizing: border-box;
            min-height: 50px;
            overflow: hidden; /* スクロールバーは表示しない */
        }

        .main-textarea {
            flex-grow: 1;
            min-height: 150px;
            resize: vertical; /* メインエディタもマニュアルリサイズ可能に */
        }

        .outline-textarea {
            min-height: 50px;
            max-height: none; /* max-heightを削除 (自動で伸びる) */
            resize: vertical; 
        }

        .character-textarea { 
            min-height: 70vh; 
            max-height: none; /* max-heightを削除 (自動で伸びる) */
            resize: vertical; 
            overflow-y: auto; /* キャラクターは内容が多いのでスクロール許可 */
        }
        
        /* シーン/ページ/セリフの動的表示用スタイル */
        .item-wrapper {
            display: flex;
            align-items: flex-start;
            padding: 2px 0;
            border-bottom: 1px dashed #eee;
            margin-bottom: 2px;
            font-family: 'Meiryo', 'Hiragino Kaku Gothic ProN', 'BIZ UDPGothic', sans-serif;
            font-size: 0.95em;
            line-height: 1.6;
            box-sizing: border-box;
            flex-shrink: 0;
            word-wrap: break-word;
            white-space: pre-wrap;
        }
        .item-wrapper textarea {
            flex-grow: 1;
            margin: 0;
            padding: 0;
            border: none;
            background: transparent;
            font-size: 1em;
            line-height: inherit;
            resize: none;
            overflow: hidden; /* スクロールバーは表示しない */
            height: auto;
            box-sizing: border-box;
        }

        /* シーンのtextarea */
        .scene-item-container textarea {
            width: 100%;
            border: 1px solid #ddd;
            border-top: none;
            padding: 5px;
            box-sizing: border-box;
            background-color: white;
            border-radius: 0;
            padding: 5px;
            overflow: hidden; 
            min-height: 40px; /* シーン説明の最小の高さ */
            max-height: none; 
            resize: none; 
            height: auto; 
        }
        
        /* ページとセリフのtextarea */
        .page-item-container textarea{ /*,}.dialogue-content textarea { */
            width: 100%;
            border: 1px solid #ddd;
            padding: 5px;
            box-sizing: border-box;
            background-color: white;
            border-radius: 0;
            overflow: hidden; 
            min-height: 40px; /* ページ説明・セリフの最小の高さ */
            max-height: none; 
            resize: none; 
            height: auto; 
        }


        .item-wrapper .content-display {
            flex-grow: 1;
            margin: 0;
            padding: 0;
            border: none;
            background: transparent;
            font-size: 1em;
            line-height: inherit;
            white-space: pre-wrap;
            word-wrap: break-word;
            min-height: 1.6em;
        }

        .line-numbers {
            width: 35px;
            text-align: right;
            padding-right: 5px;
            color: #aaa;
            font-size: 0.8em;
            flex-shrink: 0;
            user-select: none;
        }

        /* ファイルドロップ時のスタイル (このレイアウトでは直接見えないかもしれない) */
        body.drag-over .column.main-column {
            box-shadow: 0 0 15px rgba(0, 123, 255, 0.5);
            border: 2px dashed #007bff;
        }

        /* シーンカラム内の追加ボタン */
        .add-button-container {
            text-align: center;
            margin: 0;
            padding-top: 5px;
            border-top: 1px dashed #eee;
            margin-bottom: 10px;
        }
        .add-button-container button {
            background-color: #17A2B8;
            color: white;
            padding: 5px 10px;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.9em;
            width: 100%;
            box-sizing: border-box;
            margin: 0 auto;
            display: block;
        }
        .add-button-container button:hover {
            background-color: #138496;
        }

        /* シーンアイテムの具体的なスタイル */
        .scene-item-container {
            border: 1px solid #ccc;
            padding: 0px;
            margin-bottom: 10px;
            border-radius: 5px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
            display: flex;
            flex-direction: column;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        }
        /* アクティブな要素の強調表示 */
        .scene-item-container.active,
        .page-item-container.active,
        .dialogue-content.active,
        .character-item-container.active { 
            box-shadow: 0 0 8px 3px rgba(0, 123, 255, 0.5);
            border-color: #007bff;
            transform: scale(1.01);
        }

        .page-item-container {
            border: 1px solid #ccc;
            padding: 0px;
            margin: 0;
            margin-bottom: 5px;
            border-radius: 5px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
            cursor: pointer;
            transition: background-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        }

        /* シーンの背景色ローテーション用クラス */
        .scene-color-0 { background-color: #e0f7fa; }
        .scene-color-1 { background-color: #f0f4c3; }
        .scene-color-2 { background-color: #ffe0b2; } 
        .scene-color-3 { background-color: #e1bee7; }
        .scene-color-4 { background-color: #b3e5fc; }

        /* セリフ表示部分のスタイル */
        .serif-page-group-container {
            border: 1px solid #dcdcdc;
            border-radius: 5px;
            margin-bottom: 15px;
            padding: 10px;
            background-color: #fffbf0; /* 薄いオレンジ色 #fffbf0 に変更 */
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
            box-sizing: border-box;
            cursor: pointer;
        }


        .dialogue-content {
            margin-bottom: 8px;
            border-radius: 5px;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            box-sizing: border-box;
            cursor: pointer;
            transition: none;
            flex-grow: 1;
            white-space: pre-wrap;
            word-wrap: break-word;
            font-size: 0.95em;
            line-height: 1.6;
            font-style:normal; /* 親のitalicを打ち消す */
            color: #333;
            background-color: white; /* 各セリフdivの背景は白に */
            border-radius: 3px;
            width: 100%;
            border: 1px solid #ddd;
            border-left: 3px solid #f9ab00; /* セリフのdivに左ボーダーを適用 */
            padding: 5px; /* ボーダー分の調整と内容のパディング */
        }
        /* セリフのdiv内のテキストは直接表示されるので、textareaのスタイルは不要 */
        /* .dialogue-content textarea { ... } は削除 */


        .scene-item-header, .page-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 10px; /* シーンとページで共通のパディング */
            flex-shrink: 0;
        }

        .scene-title-badge {
            background-color: #007bff;
            color: white;
            padding: 3px 8px;
            border-radius: 4px;
            font-weight: bold;
            font-size: 1.0em;
            display: inline-block;
        }

        .page-title-badge {
            background-color: #007bff;
            color: white;
            padding: 3px 8px;
            border-radius: 4px;
            font-weight: bold;
            font-size: 1.0em;
            display: inline-block;
        }

        .scene-item-header .delete-scene-btn, .page-item-header .delete-page-btn {
            background-color: #dc3545;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.8em;
            transition: background-color 0.2s;
        }

        .scene-item-header .delete-scene-btn:hover, .page-item-header .delete-page-btn:hover {
            background-color: #c82333;
        }

        .section-container {
            border: 1px solid #ccc;
            border-radius: 5px;
            margin-bottom: 10px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
            background-color: #f8f8f8;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .section-header {
            background-color: #f0f0f0;
            padding: 8px 10px;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: bold;
            flex-shrink: 0;
            cursor: pointer;
        }

        .section-header h3 {
            margin: 0;
            font-size: 1em;
            color: #333;
            flex-grow: 1;
        }

        .toggle-btn, .add-character-btn {
            background-color: #6c757d;
            color: white;
            padding: 4px 8px;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.8em;
            transition: background-color 0.2s;
            margin-left: 5px;
        }

        .toggle-btn:hover, .add-character-btn:hover {
            background-color: #5a6268;
        }

        .section-content {
            padding: 10px;
            transition: max-height 0.3s ease-out, opacity 0.3s ease-out, padding 0.3s ease-out;
            overflow-y: auto; 
            max-height: none; 
            opacity: 1;
            box-sizing: border-box;
        }

        .section-content.hidden {
            max-height: 0 !important;
            padding-top: 0;
            padding-bottom: 0;
            opacity: 0;
            visibility: hidden;
        }

        /* .character-textarea, .outline-textarea, .main-textarea は個別の max-height を持つ */
        .character-textarea, .outline-textarea, .main-textarea {
            border: none;
            min-height: 50px;
            background-color: white;
            border-radius: 0;
            padding: 5px;
        }

        .main-textarea {
            min-height: 150px;
        }

        /* 個別のシーン内でページを追加するためのボタン */
        .add-page-to-scene-btn {
            background-color: #34495e; /* 紺色に変更 */
            color: white;
            padding: 5px 10px;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.9em;
            width: calc(100% - 20px); /* Padding分を考慮 */
            box-sizing: border-box;
            margin: 10px; /* シーンアイテムの下に少しマージン */
            display: block;
            text-align: center;
        }
        .add-page-to-scene-btn:hover {
            background-color: #2c3e50; /* ホバー時の色 */
        }


        /* --- スマートフォン対応のためのメディアクエリ --- */
        @media (max-width: 768px) {
            body {
                overflow-y: hidden; /* 全体スクロールを禁止 (横スライドのため) */
            }

            .columns-wrapper {
                width: 400vw; /* 4カラム分の幅 */
                transform: translateX(0vw); /* 初期表示はJSで設定 */
                transition: none; /* ここを none に変更 */
                padding-top: 0; /* グローバルヘッダーを削除したので0 */
                padding-bottom: 0; /* フッターナビを削除したので0 */
                box-sizing: border-box;
                overflow-x: hidden; /* 横スクロール禁止 (JSで制御するため) */
            }

            .column {
                width: 100vw; /* 各カラムの幅をビューポートの幅に */
                border-right: none; /* スマホではカラム間の境界線は不要 */
            }

            .column-header {
                flex-direction: column;
                align-items: flex-start;
                padding: 8px;
            }

            .column-header .header-title {
                margin-right: 0;
                margin-bottom: 5px;
            }

            .column-header .controls {
                width: 100%;
                justify-content: space-around;
                gap: 5px;
            }

            .column-header .controls button {
                flex-grow: 1;
                margin-left: 0;
                padding: 8px 5px;
                font-size: 1em;
            }

            .column-content {
                padding: 8px;
            }

            /* スマホ時のsection-contentのmax-heightも調整 */
            .section-content {
                max-height: none; /* スマホでも内部のtextareaがスクロールするように */
            }
        }

        @media (max-width: 480px) {
            .column-header .controls button {
                font-size: 0.9em;
                padding: 6px 3px;
            }

            .section-header h3 {
                font-size: 0.9em;
            }
            .toggle-btn, .add-character-btn {
                font-size: 0.7em;
                padding: 3px 6px;
            }
            
            textarea {
                font-size: 0.9em;
            }
            .line-numbers {
                width: 25px;
                font-size: 0.7em;
            }

            .section-content {
                max-height: none; /* スマホでも内部のtextareaがスクロールするように */
            }
        }
    </style>
</head>
<body>
    <div class="columns-wrapper" id="columnsWrapper">
        <div class="column main-column" data-column-id="main">
            <div class="column-header">
                <span class="header-title">メイン</span>
                <div class="controls">
                    <button id="newBtn">新規</button>
                    <button id="openBtn">開く</button>
                    <input type="file" id="fileInput" style="display: none;">
                    <button id="saveBtn">保存</button>
                    <button id="saveAsBtn">別名保存</button>
                    <button id="undoBtn">↶</button>
                    <button id="redoBtn">↷</button>
                </div>
            </div>
            <div class="column-content">
                <div class="section-container" id="outlineSection">
                    <div class="section-header">
                        <h3>アウトライン</h3>
                        <button class="toggle-btn" data-target="outlineContent">隠す</button>
                    </div>
                    <div class="section-content" id="outlineContent">
                        <textarea id="outlineEditor" class="outline-textarea" placeholder="ここに物語のアウトラインを記述してください。"></textarea>
                    </div>
                </div>
                
                <div class="section-container" id="characterSection">
                    <div class="section-header">
                        <h3>キャラクター</h3>
                        <div class="controls">
                            <button class="add-character-btn" id="addCharacterBtn">追加</button>
                            <button class="toggle-btn" data-target="characterContent">隠す</button>
                        </div>
                    </div>
                    <div class="section-content" id="characterContent">
                        <textarea id="characterEditor" class="character-textarea"></textarea>
                    </div>
                </div>

                <div class="section-container" id="mainEditorSection">
                    <div class="section-header">
                        <h3>ネーム本体 (XML)</h3>
                        <button class="toggle-btn" data-target="mainEditorContent">隠す</button>
                    </div>
                    <div class="section-content" id="mainEditorContent">
                        <textarea id="mainEditor" class="main-textarea" placeholder="XML形式でネームを記述してください。例：
<root><シーン><シーン説明>新しいシーン</シーン説明><ページ><ページ説明>新しいページ</ページ説明><セリフ>セリフA</セリフ></ページ></シーン></root>">
</textarea>
                    </div>
                </div>
            </div>
        </div>

        <div class="column scene-column" data-column-id="scene">
            <div class="column-header">
                <span class="header-title">シーン</span>
                <div class="controls">
                    <button id="addSceneBtn">シーン追加</button>
                </div>
            </div>
            <div class="column-content" id="sceneContent">
                <p>メインエディタの内容からシーンを抽出します。</p>
            </div>
        </div>

        <div class="column page-column" data-column-id="page">
            <div class="column-header">
                <span class="header-title">ページ</span>
            </div>
            <div class="column-content" id="pageContent">
                <p>メインエディタの内容からページを抽出します。</p>
            </div>
        </div>

        <div class="column serif-column" data-column-id="serif">
            <div class="column-header">
                <span class="header-title">セリフ</span>
                <div class="controls">
                    <button id="exportDialogueBtn">エクスポート</button>
                </div>
            </div>
            <div class="column-content" id="dialogueContent">
                <p>メインエディタの内容からセリフを抽出します。</p>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const outlineEditor = document.getElementById('outlineEditor');
            const characterEditor = document.getElementById('characterEditor');
            const mainEditor = document.getElementById('mainEditor');

            const sceneContentDiv = document.getElementById('sceneContent');
            const pageContentDiv = document.getElementById('pageContent');
            const dialogueContentDiv = document.getElementById('dialogueContent');

            const newBtn = document.getElementById('newBtn');
            const openBtn = document.getElementById('openBtn');
            const saveBtn = document.getElementById('saveBtn');
            const saveAsBtn = document.getElementById('saveAsBtn');
            const fileInput = document.getElementById('fileInput');
            const undoBtn = document.getElementById('undoBtn');
            const redoBtn = document.getElementById('redoBtn');

            const outlineContentDiv = document.getElementById('outlineContent');
            const characterContentDiv = document.getElementById('characterContent');
            const mainEditorContentDiv = document.getElementById('mainEditorContent');

            const toggleButtons = document.querySelectorAll('.toggle-btn');

            const addSceneBtn = document.getElementById('addSceneBtn'); 
            const addCharacterBtn = document.getElementById('addCharacterBtn');
            const exportDialogueBtn = document.getElementById('exportDialogueBtn');

            const columnsWrapper = document.getElementById('columnsWrapper');
            
            let currentFileName = '新規ネーム.txt';
            let history = [''];
            let historyIndex = 0;
            const MAX_HISTORY = 100;
            let updateTimeout;
            const DEBOUNCE_DELAY = 300; 
            let currentXmlDoc = null;
            let currentFileHandle = null;

            const xmlParser = new DOMParser();
            // const xmlSerializer = new XMLSerializer(); // XMLSerializerは使用しない

            let nodeIdCounter = 0; 

            // XMLノードとDOM要素の関連付け用マップ
            const sceneNodeIdToDomElementMap = new Map();
            const pageNodeIdToDomElementMap = new Map();
            const sceneNodeIdToFirstPageDomElementMap = new Map();
            const dialogueNodeIdToDomElementMap = new Map(); 

            let activeSceneElement = null;
            let activePageElement = null;
            let activeDialogueElement = null; // 個別のセリフ要素

            // --- カラム表示制御用の変数 ---            
            let currentColumnIndex = 0; // 0:メイン, 1:シーン, 2:ページ, 3:セリフ
            const columns = document.querySelectorAll('.column');
            let startX = 0; // touchstart時のX座標
            let currentTranslateX = 0; // columnsWrapperの現在のtranslateX値 (px値)
            let isDragging = false;
            let touchStartX = 0; // スワイプ判定用
            let touchEndX = 0;   // スワイプ判定用

            function showColumn(index) {
                if (index < 0 || index >= columns.length) return;
                currentColumnIndex = index;

                if (window.innerWidth <= 768) {
                    columnsWrapper.style.transform = `translateX(-${index * 100}vw)`;
                    columnsWrapper.style.scrollBehavior = 'auto'; 
                    // ここでの transition 設定は不要になります。
                    // columnsWrapper.style.transition = 'none'; // 即時切り替え
                } else {
                    columnsWrapper.style.transform = `translateX(0)`; 
                    columnsWrapper.style.scrollBehavior = 'smooth'; 
                    columnsWrapper.scrollLeft = columns[index].offsetLeft;
                }
            }

            function undo() {
                if (historyIndex > 0) {
                    historyIndex--;
                    mainEditor.value = history[historyIndex];
                    updateUIImmediate(); // UIを即座に更新
                }
            }

            function redo() {
                if (historyIndex < history.length - 1) {
                    historyIndex++;
                    mainEditor.value = history[historyIndex];
                    updateUIImmediate(); // UIを即座に更新
                }
            }

            function saveState() {
                const state = {
                    outlineContent: outlineEditor.value,
                    characterContent: characterEditor.value,
                    mainContent: mainEditor.value,
                    fileName: currentFileName,
                    history: history,
                    historyIndex: historyIndex,
                    outlineHidden: outlineContentDiv.classList.contains('hidden'),
                    characterHidden: characterContentDiv.classList.contains('hidden'),
                    mainEditorHidden: mainEditorContentDiv.classList.contains('hidden'),
                    currentColumnIndex: currentColumnIndex 
                };
                localStorage.setItem('comicNameEditorState', JSON.stringify(state));
                console.log('State saved.');
            }

            function clearAllEditors() {
                outlineEditor.value = '';
                characterEditor.value = `*主人公（名前：読み方、愛称）男女、歳
*関係性
*見た目、身体的特徴、服装
*性格・裏性格
*環境・生い立ち
――――――――――
*ヒロイン（名前：読み方、愛称）男女、歳
*関係性
*見た目、身体的特徴、服装
*性格・裏性格
*環境・生い立ち
――――――――――
*ライバル（名前：読み方、愛称）男女、歳
*関係性
*見た目、身体的特徴、服装
*性格・裏性格
*環境・生い立ち`;

                // 新規作成時のXML初期値に、空のセリフ要素も含むように変更
                mainEditor.value = `<root><シーン><シーン説明>新しいシーン</シーン説明><ページ><ページ説明>新しいページ</ページ説明></ページ></シーン></root>`; 
                currentFileName = '新規ネーム.txt';
                currentFileHandle = null;
                history = [mainEditor.value];
                historyIndex = 0;
                localStorage.removeItem('comicNameEditorState');
                
                setSectionVisibility(outlineContentDiv, false);
                setSectionVisibility(characterContentDiv, false);
                setSectionVisibility(mainEditorContentDiv, true);

                currentColumnIndex = 0; 
                showColumn(currentColumnIndex); 
                updateUIImmediate();
                alert('新しいネームを開始しました。');
            }


            function loadState() {
                const savedState = localStorage.getItem('comicNameEditorState');
                if (savedState) {
                    const state = JSON.parse(savedState);
                    outlineEditor.value = state.outlineContent || '';
                    characterEditor.value = state.characterContent || '';
                    mainEditor.value = state.mainContent || '';
                    currentFileName = state.fileName || '新規ネーム.txt';
                    history = state.history || [''];
                    historyIndex = state.historyIndex || 0;

                    setSectionVisibility(outlineContentDiv, state.outlineHidden || false);
                    setSectionVisibility(characterContentDiv, state.characterHidden || false);
                    setSectionVisibility(mainEditorContentDiv, state.mainEditorHidden || false);
                    
                    currentColumnIndex = state.currentColumnIndex !== undefined ? state.currentColumnIndex : 0; 
                    console.log('State loaded.');
                } else {
                    outlineEditor.value = '';
                    characterEditor.value = `*主人公（名前：読み方、愛称）男女、歳
*関係性
*見た目、身体的特徴、服装
*性格・裏性格
*環境・生い立ち
――――――――――
*ヒロイン（名前：読み方、愛称）男女、歳
*関係性
*見た目、身体的特徴、服装
*性格・裏性格
*環境・生い立ち
――――――――――
*ライバル（名前：読み方、愛称）男女、歳
*関係性
*見た目、身体的特徴、服装
*性格・裏性格
*環境・生い立ち`;

                    // 初期XML値もセリフが空でもタグがあるように変更
mainEditor.value = `<root><シーン><シーン説明>新しいシーン</シーン説明><ページ><ページ説明>新しいページ</ページ説明></ページ></シーン></root>`; 
                    history = [mainEditor.value];
                    historyIndex = 0;

                    setSectionVisibility(outlineContentDiv, false);
                    setSectionVisibility(characterContentDiv, false);
                    setSectionVisibility(mainEditorContentDiv, true);
                    currentColumnIndex = 0; 
                }
                showColumn(currentColumnIndex); 
                updateUIImmediate();
                // autoResizeAllTextareas(); // これはupdateUIImmediate内でsetTimeoutで呼び出す
            }

            function setSectionVisibility(contentDiv, isHidden) {
                const toggleBtn = contentDiv.previousElementSibling.querySelector('.toggle-btn');
                const addCharBtn = contentDiv.previousElementSibling.querySelector('.add-character-btn');
                if (isHidden) {
                    contentDiv.classList.add('hidden');
                    if (toggleBtn) toggleBtn.textContent = '開く';
                    if (addCharBtn) addCharBtn.style.display = 'none';
                } else {
                    contentDiv.classList.remove('hidden');
                    if (toggleBtn) toggleBtn.textContent = '隠す';
                    if (addCharBtn) addCharBtn.style.display = 'inline-block';
                }
                if (!isHidden && contentDiv.querySelector('textarea')) { 
                    autoResizeTextArea(contentDiv.querySelector('textarea'));
                }
            }

            function updateUI() {
                clearTimeout(updateTimeout);
                updateTimeout = setTimeout(() => {
                    updateUndoRedoButtons();
                    syncColumnsFromMainEditor();
                    setTimeout(autoResizeAllTextareas, 50); // Small delay
                    saveState();
                    console.log('UI updated and State saved (debounced).');
                }, DEBOUNCE_DELAY);
            }

            function updateUIImmediate() {
                updateUndoRedoButtons();
                syncColumnsFromMainEditor();
                setTimeout(autoResizeAllTextareas, 50); // Small delay to ensure DOM is rendered before resizing
                saveState();
                console.log('UI updated and State saved (immediate).');
            }

            function updateUndoRedoButtons() {
                undoBtn.disabled = historyIndex === 0;
                redoBtn.disabled = historyIndex === history.length - 1;
            }

            function addToHistory(content) {
                if (history.length > 0 && history[historyIndex] === content) {
                    return;
                }
                if (historyIndex < history.length - 1) {
                    history = history.slice(0, historyIndex + 1);
                }
                history.push(content);
                if (history.length > MAX_HISTORY) {
                    history.shift();
                } else {
                    historyIndex++;
                }
                updateUndoRedoButtons();
            }

            openBtn.addEventListener('click', async () => {
                try {
                    const [fileHandle] = await window.showOpenFilePicker({
                        types: [
                            {
                                description: 'Text Files',
                                accept: {
                                    'text/plain': ['.txt'],
                                },
                            },
                        ],
                    });
                    const file = await fileHandle.getFile();
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        extractAndSetSeparateContents(event.target.result);
                        currentFileName = file.name;
                        currentFileHandle = fileHandle;
                        history = [mainEditor.value];
                        historyIndex = 0;
                        updateUIImmediate();
                    };
                    reader.onerror = () => {
                        alert('ファイルの読み込みに失敗しました。');
                    };
                    reader.readAsText(file);
                } catch (err) {
                    if (err.name === 'AbortError') {
                        console.log('File picker was cancelled.');
                    } else {
                        console.error('Error opening file:', err);
                        alert('ファイルのオープン中にエラーが発生しました。');
                    }
                }
            });

            async function saveContentToDisk(handle = null, silent = false) { // silent引数を追加
                const xmlContent = mainEditor.value;
                const fullContentToSave = `[アウトライン:]\n${outlineEditor.value}\n\n` +
                                          `[キャラクター:]\n${characterEditor.value}\n\n` +
                                          `[ネーム本体(XML):]\n${xmlContent}\n\n` +
                                          `[セリフ一覧(今後廃止):]\n`;

                try {
                    if (handle) { // fileHandleが渡された場合（簡易保存）
                        try {
                            const writable = await handle.createWritable();
                            await writable.write(fullContentToSave);
                            await writable.close();
                            if (!silent) { // silentがtrueの場合はアラートを出さない
                                alert(`ファイルを保存しました: ${handle.name}`);
                            }
                            currentFileHandle = handle; // 成功したハンドルを現在のハンドルとして保持
                            currentFileName = handle.name;
                            return true; // 成功したらtrueを返す
                        } catch (writeError) {
                            console.warn('簡易保存に失敗しました。別名保存を試みます:', writeError); // ファイルが移動されたなどで上書き保存できない場合は、フォールバックで別名保存
                        }
                    }

                    // handleがnullの場合、または簡易保存に失敗した場合
                    const newHandle = await window.showSaveFilePicker({
                        types: [
                            {
                                description: 'Text Files',
                                accept: {
                                    'text/plain': ['.txt'],
                                },
                            },
                        ],
                        suggestedName: currentFileName
                    });
                    const writable = await newHandle.createWritable();
                    await writable.write(fullContentToSave);
                    await writable.close();
                    if (!silent) { // silentがtrueの場合はアラートを出さない
                        alert(`ファイルを保存しました: ${newHandle.name}`);
                    }
                    currentFileHandle = newHandle; // 新しいファイルハンドルを保存
                    currentFileName = newHandle.name; // 新しいファイル名を保存
                    return true; // 成功したらtrueを返す
                } catch (err) {
                    if (err.name === 'AbortError') {
                        console.log('Save operation was cancelled.');
                    } else {
                        console.error('Error saving file:', err);
                        alert('ファイルの保存中にエラーが発生しました。');
                    }
                    return false; // 失敗したらfalseを返す
                }
            }

            saveBtn.addEventListener('click', async () => {
                if (currentFileHandle) { // 既にファイルハンドルが存在する場合
                    const overwriteConfirmed = confirm(`「${currentFileName}」に上書き保存しますか？\n\nキャンセルを選ぶと、名前を変えて保存するか選択できます。`);
                    if (overwriteConfirmed) { // はい（上書き）
                        await saveContentToDisk(currentFileHandle, false); // silentをfalseにしてアラートを出す
                    } else { // いいえ（キャンセル） -> 名前を変えて保存するか尋ねる
                        const saveAsConfirmed = confirm('名前を変えて保存しますか？');
                        if (saveAsConfirmed) { // はい（名前を変えて保存）
                            await saveContentToDisk(null, false); // silentをfalseにしてアラートを出す
                        }
                        // いいえ（キャンセル） -> 何もしない
                    }
                } else { // ファイルハンドルがまだ存在しない場合（初回保存）
                    await saveContentToDisk(null, false); // silentをfalseにしてアラートを出す
                }
            });

            saveAsBtn.addEventListener('click', async () => {
                // 常に別名保存ダイアログを開く
                await saveContentToDisk(null, false); // silentをfalseにしてアラートを出す
            });


            const mainColumn = document.querySelector('.column.main-column');

            document.body.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.stopPropagation();
                if (window.innerWidth > 768) {
                    document.body.classList.add('drag-over');
                }
            });

            document.body.addEventListener('dragleave', (e) => {
                if (window.innerWidth > 768) {
                    if (!mainColumn.contains(e.relatedTarget) && e.relatedTarget !== null) {
                        document.body.classList.remove('drag-over');
                    }
                }
            });

            mainColumn.addEventListener('drop', async (e) => {
                e.preventDefault();
                document.body.classList.remove('drag-over');

                const file = e.dataTransfer.files[0];
                if (file && file.type === 'text/plain') {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        extractAndSetSeparateContents(event.target.result);
                        currentFileName = file.name;
                        currentFileHandle = null; // ドラッグ＆ドロップで開いた場合はハンドルをリセット
                        history = [mainEditor.value];
                        historyIndex = 0;
                        updateUIImmediate();
                    };
                    reader.onerror = () => {
                        alert('ファイルの読み込みに失敗しました。');
                    };
                    reader.readAsText(file);
                }
            });

            function extractAndSetSeparateContents(fullText) {
                const extracted = { outline: '', character: '', main: '' };

                const outlineMatch = fullText.match(/\[アウトライン:\]\n([\s\S]*?)(?=\n*\[キャラクター:\]|\n*\[ネーム本体\(XML\):\]|\n*\[セリフ一覧\(今後廃止\):\]|$)/);
                if (outlineMatch) extracted.outline = outlineMatch[1].trim();
                else if (fullText.includes('[アウトライン:]')) extracted.outline = ''; // タグはあるが内容がない場合

                const characterMatch = fullText.match(/\[キャラクター:\]\n([\s\S]*?)(?=\n*\[ネーム本体\(XML\):\]|\n*\[セリフ一覧\(今後廃止\):\]|$)/);
                if (characterMatch) extracted.character = characterMatch[1].trim();
                else if (fullText.includes('[キャラクター:]')) extracted.character = ''; // タグはあるが内容がない場合

                const mainXmlMatch = fullText.match(/\[ネーム本体\(XML\):\]\n([\s\S]*?)(?=\n*\[セリフ一覧\(今後廃止\):\]|$)/);
                if (mainXmlMatch) extracted.main = mainXmlMatch[1].trim();
                else if (fullText.includes('[ネーム本体(XML):]')) extracted.main = ''; // タグはあるが内容がない場合

                // どのセクションタグも見つからなかった場合は、mainEditorに全て入れる
                if (!outlineMatch && !characterMatch && !mainXmlMatch) {
                    extracted.main = fullText;
                }

                outlineEditor.value = extracted.outline;
                characterEditor.value = extracted.character;
                mainEditor.value = extracted.main;
            }

            // カスタムXMLシリアライズ関数
            function serializeXmlToCompactString(node) {
                let result = '';
                if (!node) {
                    return result;
                }

                if (node.nodeType === Node.ELEMENT_NODE) {
                    result += `<${node.tagName}>`;
                    for (let child of node.childNodes) {
                        result += serializeXmlToCompactString(child);
                    }
                    result += `</${node.tagName}>`;
                } else if (node.nodeType === Node.TEXT_NODE) {
                    // XMLエンティティをエスケープ
                    result += node.textContent
                        .replace(/&/g, '&amp;')
                        .replace(/</g, '&lt;')
                        .replace(/>/g, '&gt;')
                        .replace(/"/g, '&quot;')
                        .replace(/'/g, '&apos;');
                } else if (node.nodeType === Node.CDATA_SECTION_NODE) {
                    result += `<![CDATA[${node.textContent}]]>`;
                } else if (node.nodeType === Node.COMMENT_NODE) {
                    result += ``;
                }
                // 他のノードタイプは無視
                return result;
            }


            function syncColumnsFromMainEditor() {
                const mainText = mainEditor.value;

                // マップをクリアして再構築
                sceneNodeIdToDomElementMap.clear();
                pageNodeIdToDomElementMap.clear();
                sceneNodeIdToFirstPageDomElementMap.clear();
                dialogueNodeIdToDomElementMap.clear(); 
                nodeIdCounter = 0; // ノードIDカウンターをリセット

                try {
                    let textToParse = mainText.trim();
                    if (!textToParse.startsWith('<root>') || !textToParse.endsWith('</root>')) {
                        // rootタグがない場合でもパースを試みるが、エラーになる可能性を考慮
                        textToParse = `<root>${textToParse}</root>`;
                    }
                    currentXmlDoc = xmlParser.parseFromString(textToParse, 'application/xml');

                    const parserError = currentXmlDoc.querySelector('parsererror');
                    if (parserError) {
                        console.error('XML Parsing Error:', parserError.textContent);
                        const errorMessage = '<p style="color: red;">XMLパースエラー: メインエディタの記述を確認してください。</p>';
                        sceneContentDiv.innerHTML = errorMessage;
                        pageContentDiv.innerHTML = errorMessage;
                        dialogueContentDiv.innerHTML = errorMessage;
                        return; // <--- IMPORTANT: Returns here on parse error.
                    }
                } catch (e) {
                    console.error('Failed to parse XML:', e);
                    const errorMessage = '<p style="color: red;">XMLパースに失敗しました。</p>';
                    sceneContentDiv.innerHTML = errorMessage;
                    pageContentDiv.innerHTML = errorMessage;
                    dialogueContentDiv.innerHTML = errorMessage;
                    return; // <--- IMPORTANT: Returns here on parse error.
                }

                const scenes = currentXmlDoc.querySelectorAll('シーン');
                const sceneItems = [];
                scenes.forEach((sceneElement, index) => {
                    const nodeId = `node-${nodeIdCounter++}`;
                    sceneItems.push({
                        title: `シーン${index + 1}`,
                        text: sceneElement.querySelector('シーン説明')?.textContent || '',
                        nodeId: nodeId,
                        rawNode: sceneElement,
                        sceneIndex: index
                    });
                });
                renderSceneColumnContent(sceneContentDiv, sceneItems);

                // --- ページカラムの描画 ---
                pageContentDiv.innerHTML = '';
                let globalPageIndex = 1;

                if (scenes.length === 0) {
                    const p = document.createElement('p');
                    p.textContent = `メインエディタの内容からページを抽出します。`;
                    pageContentDiv.appendChild(p);
                } else {
                    scenes.forEach((sceneElement, sceneIndex) => {
                        const sceneNodeIdForDom = [...sceneNodeIdToDomElementMap.keys()].find(key => sceneNodeIdToDomElementMap.get(key).xmlNode === sceneElement);
                        const sceneTitle = `シーン${sceneIndex + 1}`;
                        const sceneColorClass = `scene-color-${sceneIndex % 5}`;

                        const pagesInScene = sceneElement.querySelectorAll('ページ');

                        if (pagesInScene.length === 0) {
                            const p = document.createElement('p');
                            p.textContent = `このシーンにはページがありません。`;
                            p.style.fontSize = '0.9em';
                            p.style.color = '#777';
                            p.style.marginLeft = '10px';
                            p.style.marginBottom = '10px';
                            pageContentDiv.appendChild(p);
                        }

                        pagesInScene.forEach((pageElement, pageIndexInScene) => { // pageIndexInSceneを追加
                            const nodeId = `node-${nodeIdCounter++}`;
                            const pageItemContainer = document.createElement('div');
                            pageItemContainer.classList.add('page-item-container');
                            pageItemContainer.setAttribute('data-node-id', nodeId);
                            pageItemContainer.xmlNode = pageElement; // XMLノードをDOM要素に紐付け
                            pageItemContainer.setAttribute('data-parent-scene-id', sceneNodeIdForDom); // 親シーンのDOM IDを保持
                            pageItemContainer.setAttribute('data-scene-index', sceneIndex); // シーンのインデックス
                            pageItemContainer.setAttribute('data-page-index-in-scene', pageIndexInScene); // シーン内のページインデックス
                            pageItemContainer.classList.add(sceneColorClass);

                            pageItemContainer.addEventListener('click', (event) => {
                                setActiveElement(pageItemContainer, 'page');
                                // showColumn(2); // ページカラムはインデックス2 - ページクリック時に移動しないように修正済み
                                
                                // PC画面の場合のみ、シーンカラムへ移動
                                if (window.innerWidth > 768) {
                                    const clickedPageItem = event.target.closest('.page-item-container');
                                    if (clickedPageItem) {
                                        const sceneIdx = parseInt(clickedPageItem.dataset.sceneIndex);
                                        highlightScene(sceneIdx);
                                        // showColumn(1); // シーンカラムはインデックス1 - シーンクリック時に移動しないように修正済み
                                    }
                                }
                                
                                if (window.innerWidth > 768) {
                                    pageItemContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });
                                }
                            });

                            const pageHeader = document.createElement('div');
                            pageHeader.classList.add('page-item-header');
                            const pageTitleBadge = document.createElement('span');
                            pageTitleBadge.classList.add('page-title-badge');
                            pageTitleBadge.textContent = `ページ${globalPageIndex}`;
                            pageHeader.appendChild(pageTitleBadge);

                            const deleteButton = document.createElement('button');
                            deleteButton.classList.add('delete-page-btn');
                            deleteButton.textContent = '削除';
                            deleteButton.addEventListener('click', (e) => {
                                e.stopPropagation(); // 親要素へのクリックイベント伝播を停止
                                deletePage(pageItemContainer.xmlNode, `ページ${globalPageIndex}`);
                            });
                            pageHeader.appendChild(deleteButton);
                            pageItemContainer.appendChild(pageHeader);

                            const itemTextArea = document.createElement('textarea');
                            // <ページ説明>と<セリフ>の内容を結合してtextareaに表示
                            let combinedText = '';
                            pageElement.childNodes.forEach(child => {
                                if (child.nodeType === Node.ELEMENT_NODE) {
                                    if (child.tagName === 'ページ説明') {
                                        combinedText += child.textContent;
                                    } else if (child.tagName === 'セリフ') {
                                        combinedText += `「${child.textContent}」`;
                                    }
                                } else if (child.nodeType === Node.TEXT_NODE && child.textContent.trim().length > 0) {
                                    // 要素間のテキストノードも考慮（ただし、今回のXML構造ではあまり発生しないはず）
                                    combinedText += child.textContent;
                                }
                            });
                            itemTextArea.value = combinedText;
                            itemTextArea.classList.add('page-text');
                            itemTextArea.placeholder = 'ページ内の説明やセリフ';

                            itemTextArea.addEventListener('input', (e) => {
                                autoResizeTextArea(e.target);
                                // updatePageContentInXmlに、DOM要素の参照とテキスト、そしてシーンとページインデックスを渡す
                                updatePageContentInXml(
                                    pageItemContainer.getAttribute('data-scene-index'),
                                    pageItemContainer.getAttribute('data-page-index-in-scene'),
                                    e.target.value // 入力されたテキスト全体を渡す
                                );
                            });
                            itemTextArea.addEventListener('change', () => {
                                updateUIImmediate();
                            });
                            itemTextArea.addEventListener('focus', () => {
                                setActiveElement(pageItemContainer, 'page');
                            });


                            pageItemContainer.appendChild(itemTextArea);
                            pageContentDiv.appendChild(pageItemContainer);
                            pageNodeIdToDomElementMap.set(nodeId, { domElement: pageItemContainer, xmlNode: pageElement });

                            // シーン内の最初のページアイテムをマップに保存（シーンクリック時のスクロール用）
                            if (pageIndexInScene === 0) {
                                sceneNodeIdToFirstPageDomElementMap.set(sceneElement.getAttribute('data-node-id'), pageItemContainer);
                            }

                            globalPageIndex++;
                        }); // End of pagesInScene.forEach
                    }); // End of scenes.forEach
                } // End of else (scenes.length > 0)


                // --- セリフカラムの描画 ---
                dialogueContentDiv.innerHTML = '';
                const allDialogues = currentXmlDoc.querySelectorAll('セリフ');

                if (allDialogues.length === 0) {
                    const p = document.createElement('p');
                    p.textContent = `メインエディタの内容からセリフを抽出します。`;
                    dialogueContentDiv.appendChild(p);
                } else {
                    let currentSerifPageGroup = null;
                    let currentSerifPageGroupSceneIndex = -1;
                    let currentSerifPageGroupPageIndex = -1;

                    allDialogues.forEach((dialogueElement, dialogueIndex) => {
                        // 親の<ページ>要素を取得
                        const parentPageElement = dialogueElement.closest('ページ');
                        const parentSceneElement = dialogueElement.closest('シーン');

                        if (parentPageElement && parentSceneElement) {
                            const sceneIndex = Array.from(currentXmlDoc.querySelectorAll('シーン')).indexOf(parentSceneElement);
                            const pageIndexInScene = Array.from(parentSceneElement.querySelectorAll('ページ')).indexOf(parentPageElement);

                            // シーンとページが変わったら新しいグループを作成
                            if (currentSerifPageGroupSceneIndex !== sceneIndex || currentSerifPageGroupPageIndex !== pageIndexInScene) {
                                currentSerifPageGroup = document.createElement('div');
                                currentSerifPageGroup.classList.add('serif-page-group-container');
                                currentSerifPageGroup.classList.add(`scene-color-${sceneIndex % 5}`); // シーンの色を適用
                                currentSerifPageGroup.innerHTML = `<div style="font-weight: bold; margin-bottom: 5px;">シーン${sceneIndex + 1} - ページ${Array.from(currentXmlDoc.querySelectorAll('ページ')).indexOf(parentPageElement) + 1}</div>`;
                                dialogueContentDiv.appendChild(currentSerifPageGroup);
                                currentSerifPageGroupSceneIndex = sceneIndex;
                                currentSerifPageGroupPageIndex = pageIndexInScene;
                            }

                            const dialogueDiv = document.createElement('div');
                            dialogueDiv.classList.add('dialogue-content');
                            dialogueDiv.textContent = dialogueElement.textContent;
                            dialogueDiv.setAttribute('data-node-id', `node-${nodeIdCounter++}`);
                            dialogueDiv.xmlNode = dialogueElement;
                            dialogueDiv.setAttribute('data-scene-index', sceneIndex);
                            dialogueDiv.setAttribute('data-page-index-in-scene', pageIndexInScene);
                            dialogueDiv.setAttribute('data-dialogue-index-in-page', Array.from(parentPageElement.querySelectorAll('セリフ')).indexOf(dialogueElement)); // ページ内のセリフインデックス

                            dialogueDiv.addEventListener('click', () => {
                                setActiveElement(dialogueDiv, 'dialogue');
                                showColumn(3); // セリフカラムはインデックス3
                                if (window.innerWidth > 768) {
                                    dialogueDiv.scrollIntoView({ behavior: 'smooth', block: 'center' });
                                }
                            });

                            currentSerifPageGroup.appendChild(dialogueDiv);
                            dialogueNodeIdToDomElementMap.set(dialogueDiv.getAttribute('data-node-id'), { domElement: dialogueDiv, xmlNode: dialogueElement });
                        }
                    });
                }


                // アクティブな要素を再強調表示
                if (activeSceneElement) {
                    const sceneDataId = activeSceneElement.getAttribute('data-node-id');
                    if (sceneNodeIdToDomElementMap.has(sceneDataId)) {
                        setActiveElement(sceneNodeIdToDomElementMap.get(sceneDataId).domElement, 'scene', false);
                    } else {
                        activeSceneElement = null;
                    }
                }
                if (activePageElement) {
                    const pageDataId = activePageElement.getAttribute('data-node-id');
                    if (pageNodeIdToDomElementMap.has(pageDataId)) {
                        setActiveElement(pageNodeIdToDomElementMap.get(pageDataId).domElement, 'page', false);
                    } else {
                        activePageElement = null;
                    }
                }
                if (activeDialogueElement) {
                    const dialogueDataId = activeDialogueElement.getAttribute('data-node-id');
                    if (dialogueNodeIdToDomElementMap.has(dialogueDataId)) {
                        setActiveElement(dialogueNodeIdToDomElementMap.get(dialogueDataId).domElement, 'dialogue', false);
                    } else {
                        activeDialogueElement = null;
                    }
                }
            }


            // シーンカラムのコンテンツをレンダリングする関数
            function renderSceneColumnContent(targetDiv, sceneItems) {
                targetDiv.innerHTML = ''; // 既存の内容をクリア

                if (sceneItems.length === 0) {
                    const p = document.createElement('p');
                    p.textContent = `メインエディタの内容からシーンを抽出します。`;
                    targetDiv.appendChild(p);
                    return;
                }

                sceneItems.forEach((sceneData, index) => {
                    const sceneItemContainer = document.createElement('div');
                    sceneItemContainer.classList.add('scene-item-container');
                    sceneItemContainer.setAttribute('data-node-id', sceneData.nodeId);
                    sceneItemContainer.xmlNode = sceneData.rawNode; // XMLノードをDOM要素に紐付け
                    sceneItemContainer.setAttribute('data-scene-index', index); // シーンのインデックスをカスタムデータ属性として追加

                    // シーンの背景色をローテーション
                    sceneItemContainer.classList.add(`scene-color-${index % 5}`);

                    sceneItemContainer.addEventListener('click', () => {
                        setActiveElement(sceneItemContainer, 'scene');
                        // showColumn(1); // シーンカラムへの自動移動を削除

                        // 対応するXMLノードをメインエディタで強調表示
                        const mainEditorText = mainEditor.value;
                        const startIndex = mainEditorText.indexOf(`<シーン><シーン説明>${sceneData.text}</シーン説明>`);
                        if (startIndex !== -1) {
                            // mainEditor.focus();
                            // mainEditor.setSelectionRange(startIndex, startIndex + `<シーン><シーン説明>${sceneData.text}</シーン説明>`.length);
                            // TODO: XML全体から該当シーンの範囲を特定し、スクロール・選択する
                        }

                        // 対応する最初のページアイテムにスクロール
                        const firstPageInScene = sceneData.rawNode.querySelector('ページ');
                        if (firstPageInScene) {
                            const firstPageDomElement = sceneNodeIdToFirstPageDomElementMap.get(sceneData.nodeId);
                            if (firstPageDomElement && window.innerWidth > 768) {
                                firstPageDomElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
                            }
                        }
                    });

                    // シーンヘッダー
                    const sceneHeader = document.createElement('div');
                    sceneHeader.classList.add('scene-item-header');

                    const sceneTitleBadge = document.createElement('span');
                    sceneTitleBadge.classList.add('scene-title-badge');
                    sceneTitleBadge.textContent = sceneData.title;
                    sceneHeader.appendChild(sceneTitleBadge);

                    const deleteButton = document.createElement('button');
                    deleteButton.classList.add('delete-scene-btn');
                    deleteButton.textContent = '削除';
                    deleteButton.addEventListener('click', (e) => {
                        e.stopPropagation(); // 親要素へのクリックイベント伝播を停止
                        deleteScene(sceneData.rawNode, sceneData.title);
                    });
                    sceneHeader.appendChild(deleteButton);
                    sceneItemContainer.appendChild(sceneHeader);

                    // シーン説明テキストエリア
                    const itemTextArea = document.createElement('textarea');
                    itemTextArea.value = sceneData.text;
                    itemTextArea.classList.add('scene-text');
                    itemTextArea.placeholder = 'ここにシーンの説明を記述';
                    itemTextArea.addEventListener('input', (e) => {
                        autoResizeTextArea(e.target);
                        updateSceneDescriptionInXml(sceneData.rawNode, e.target.value);
                    });
                    itemTextArea.addEventListener('change', () => {
                        updateUIImmediate(); // 変更が確定したらUI全体を更新
                    });
                    itemTextArea.addEventListener('focus', () => {
                        setActiveElement(sceneItemContainer, 'scene');
                    });
                    sceneItemContainer.appendChild(itemTextArea);

                    // ページ追加ボタン
                    const addPageButton = document.createElement('button');
                    addPageButton.classList.add('add-page-to-scene-btn');
                    addPageButton.textContent = 'ページ追加';
                    addPageButton.addEventListener('click', (e) => {
                        e.stopPropagation(); // 親要素へのクリックイベント伝播を停止
                        addPageToScene(sceneData.rawNode);
                    });
                    sceneItemContainer.appendChild(addPageButton);

                    targetDiv.appendChild(sceneItemContainer);

                    // XMLノードとDOM要素の関連付けをマップに保存
                    sceneNodeIdToDomElementMap.set(sceneData.nodeId, { domElement: sceneItemContainer, xmlNode: sceneData.rawNode });
                });
            }

            // シーンのハイライト機能
            function highlightScene(sceneIndex) {
                // まず全てのシーンアイテムからactiveクラスを削除
                document.querySelectorAll('.scene-item-container').forEach(item => {
                    item.classList.remove('active');
                });

                // 指定されたシーンインデックスに対応するシーンアイテムを探してactiveクラスを追加
                const targetSceneItem = document.querySelector(`.scene-item-container[data-scene-index="${sceneIndex}"]`);
                if (targetSceneItem) {
                    targetSceneItem.classList.add('active');
                    // シーンカラムが表示されている場合のみスクロール
                    if (currentColumnIndex === 1 && window.innerWidth > 768) {
                        targetSceneItem.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                }
            }


            function setActiveElement(element, type, doScroll = true) {
                // すべてのactiveクラスを削除
                document.querySelectorAll('.active').forEach(el => el.classList.remove('active'));

                // クリックされた要素にactiveクラスを追加
                element.classList.add('active');

                // アクティブな要素を追跡
                if (type === 'scene') {
                    activeSceneElement = element;
                    activePageElement = null;
                    activeDialogueElement = null;
                } else if (type === 'page') {
                    activePageElement = element;
                    activeSceneElement = null;
                    activeDialogueElement = null;
                    // ページクリック時に対応するシーンをハイライト
                    const sceneIndex = parseInt(element.dataset.sceneIndex);
                    highlightScene(sceneIndex);
                } else if (type === 'dialogue') {
                    activeDialogueElement = element;
                    activeSceneElement = null;
                    activePageElement = null;
                }

                if (doScroll && window.innerWidth > 768) {
                    // PC表示の場合のみ、要素をスクロール
                    element.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            }


            // シーンの説明をXMLに更新する
            function updateSceneDescriptionInXml(sceneXmlNode, newText) {
                let sceneDescElement = sceneXmlNode.querySelector('シーン説明');
                if (!sceneDescElement) {
                    sceneDescElement = currentXmlDoc.createElement('シーン説明');
                    sceneXmlNode.prepend(sceneDescElement); // <シーン>タグの直下、一番前に挿入
                }
                sceneDescElement.textContent = newText;
                mainEditor.value = serializeXmlToCompactString(currentXmlDoc.documentElement);
                addToHistory(mainEditor.value);
                updateUI(); // UI更新をトリガー
            }

            // ページの内容（説明とセリフ）をXMLに更新する
            function updatePageContentInXml(sceneIndex, pageIndexInScene, newText) {
                const sceneXmlNode = currentXmlDoc.querySelectorAll('シーン')[sceneIndex];
                if (!sceneXmlNode) {
                    console.error(`Scene at index ${sceneIndex} not found.`);
                    return;
                }
                const pageXmlNode = sceneXmlNode.querySelectorAll('ページ')[pageIndexInScene];
                if (!pageXmlNode) {
                    console.error(`Page at index ${pageIndexInScene} in scene ${sceneIndex} not found.`);
                    return;
                }

                // 既存の<ページ説明>と<セリフ>を全て削除
                Array.from(pageXmlNode.childNodes).forEach(child => {
                    if (child.nodeType === Node.ELEMENT_NODE && (child.tagName === 'ページ説明' || child.tagName === 'セリフ')) {
                        pageXmlNode.removeChild(child);
                    } else if (child.nodeType === Node.TEXT_NODE && child.textContent.trim() === '') {
                        // 空のテキストノードも削除（整形のため）
                        pageXmlNode.removeChild(child);
                    }
                });

                // 入力テキストを「セリフ」で分割
                const parts = newText.split(/「(.*?)」/g); // セリフの前後で分割

                parts.forEach((part, index) => {
                    if (index % 2 === 0) { // セリフ以外の部分（ページ説明）
                        const trimmedPart = part.trim();
                        if (trimmedPart) {
                            const pageDescElement = currentXmlDoc.createElement('ページ説明');
                            pageDescElement.textContent = trimmedPart;
                            pageXmlNode.appendChild(pageDescElement);
                        }
                    } else { // セリフの部分
                        const dialogueElement = currentXmlDoc.createElement('セリフ');
                        dialogueElement.textContent = part.trim(); // 「」は含まない
                        pageXmlNode.appendChild(dialogueElement);
                    }
                });

                // XMLを更新してメインエディタに反映
                mainEditor.value = serializeXmlToCompactString(currentXmlDoc.documentElement);
                addToHistory(mainEditor.value);
                updateUI(); // UI更新をトリガー
            }


            // シーンの追加
            addSceneBtn.addEventListener('click', () => {
                addScene();
            });

            function addScene() {
                const rootElement = currentXmlDoc.documentElement;
                if (!rootElement) {
                    // root要素がない場合、初期XMLを作成
                    mainEditor.value = `<root><シーン><シーン説明>新しいシーン</シーン説明><ページ><ページ説明>新しいページ</ページ説明></ページ></シーン></root>`;
                    currentXmlDoc = xmlParser.parseFromString(mainEditor.value, 'application/xml');
                    addToHistory(mainEditor.value);
                    updateUIImmediate();
                    return;
                }

                const newScene = currentXmlDoc.createElement('シーン');
                const newSceneDesc = currentXmlDoc.createElement('シーン説明');
                newSceneDesc.textContent = '新しいシーン';
                newScene.appendChild(newSceneDesc);

                // 新しいシーンに最初のページを追加
                const newPage = currentXmlDoc.createElement('ページ');
                const newPageDesc = currentXmlDoc.createElement('ページ説明');
                newPageDesc.textContent = '新しいページ';
                newPage.appendChild(newPageDesc);
                newScene.appendChild(newPage);

                rootElement.appendChild(newScene); // root要素の最後に追加
                mainEditor.value = serializeXmlToCompactString(currentXmlDoc.documentElement);
                addToHistory(mainEditor.value);
                updateUIImmediate();
            }

            // シーンの削除
            function deleteScene(sceneXmlNode, sceneTitle) {
                if (confirm(`${sceneTitle} を削除しますか？この操作は元に戻せません。`)) {
                    sceneXmlNode.parentNode.removeChild(sceneXmlNode);
                    mainEditor.value = serializeXmlToCompactString(currentXmlDoc.documentElement);
                    addToHistory(mainEditor.value);
                    updateUIImmediate();
                }
            }

            // ページをシーンに追加する
            function addPageToScene(sceneXmlNode) {
                const newPage = currentXmlDoc.createElement('ページ');
                const newPageDesc = currentXmlDoc.createElement('ページ説明');
                newPageDesc.textContent = '新しいページ';
                newPage.appendChild(newPageDesc);

                // 新しいページに最初のセリフを追加 (空でも良い)
                // const newDialogue = currentXmlDoc.createElement('セリフ');
                // newDialogue.textContent = ''; // 空のセリフ
                // newPage.appendChild(newDialogue);

                sceneXmlNode.appendChild(newPage);
                mainEditor.value = serializeXmlToCompactString(currentXmlDoc.documentElement);
                addToHistory(mainEditor.value);
                updateUIImmediate();
            }

            // ページの削除
            function deletePage(pageXmlNode, pageTitle) {
                if (confirm(`${pageTitle} を削除しますか？この操作は元に戻せません。`)) {
                    pageXmlNode.parentNode.removeChild(pageXmlNode);
                    mainEditor.value = serializeXmlToCompactString(currentXmlDoc.documentElement);
                    addToHistory(mainEditor.value);
                    updateUIImmediate();
                }
            }

            // セリフのエクスポート機能
            exportDialogueBtn.addEventListener('click', () => {
                exportDialogue();
            });

            function exportDialogue() {
                const allDialogues = currentXmlDoc.querySelectorAll('セリフ');
                let dialogueText = '';

                // シーンとページ情報を取得
                const scenes = currentXmlDoc.querySelectorAll('シーン');
                let globalPageIndex = 1;

                scenes.forEach((sceneElement, sceneIndex) => {
                    const sceneDesc = sceneElement.querySelector('シーン説明')?.textContent || `シーン${sceneIndex + 1} (説明なし)`;
                    const pagesInScene = sceneElement.querySelectorAll('ページ');

                    pagesInScene.forEach((pageElement, pageIndexInScene) => {
                        const pageDesc = pageElement.querySelector('ページ説明')?.textContent || '';
                        const dialoguesInPage = pageElement.querySelectorAll('セリフ');

                        if (dialoguesInPage.length > 0) {
                            dialogueText += `◆ シーン${sceneIndex + 1} (${sceneDesc}) - ページ${globalPageIndex}\n`;
                            if (pageDesc) {
                                dialogueText += `　ページ説明: ${pageDesc}\n`;
                            }
                            dialoguesInPage.forEach((dialogue, dialogueIndex) => {
                                dialogueText += `　セリフ${dialogueIndex + 1}: 「${dialogue.textContent}」\n`;
                            });
                            dialogueText += '\n'; // 各ページのセリフの後に空行
                        }
                        globalPageIndex++;
                    });
                });

                if (dialogueText === '') {
                    alert('エクスポートするセリフがありません。');
                    return;
                }

                const blob = new Blob([dialogueText], { type: 'text/plain;charset=utf-8' });
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = `${currentFileName.replace('.txt', '')}_セリフ一覧.txt`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(a.href);
            }


            // テキストエリアの自動リサイズ
            function autoResizeTextArea(textarea) {
                if (textarea.classList.contains('character-textarea') && window.innerWidth <= 768) {
                    // キャラクターエリアはスマホで勝手に伸びると邪魔なので最小高さを保つ
                    textarea.style.height = 'auto'; // 一度高さをリセット
                    textarea.style.height = `${Math.max(textarea.scrollHeight, textarea.clientHeight)}px`; // 最小値の考慮
                } else if (textarea.classList.contains('outline-textarea') || textarea.classList.contains('main-textarea') || textarea.classList.contains('scene-text') || textarea.classList.contains('page-text')) {
                    textarea.style.height = 'auto'; // 一度高さをリセット
                    textarea.style.height = `${textarea.scrollHeight}px`;
                }
            }
            
            function autoResizeAllTextareas() {
                document.querySelectorAll('textarea').forEach(autoResizeTextArea);
            }

            // セクションの表示/非表示トグル機能
            toggleButtons.forEach(button => {
                button.addEventListener('click', (e) => {
                    const targetId = e.target.dataset.target;
                    const targetContent = document.getElementById(targetId);
                    if (targetContent) {
                        const isHidden = targetContent.classList.contains('hidden');
                        setSectionVisibility(targetContent, !isHidden);
                        saveState(); // 状態変更を保存
                    }
                });
            });


            // --- イベントリスナー ---
            mainEditor.addEventListener('input', () => {
                addToHistory(mainEditor.value);
                updateUI();
            });
            outlineEditor.addEventListener('input', () => {
                autoResizeTextArea(outlineEditor);
                saveState(); // アウトラインの変更も保存対象に
            });
            characterEditor.addEventListener('input', () => {
                autoResizeTextArea(characterEditor);
                saveState(); // キャラクターの変更も保存対象に
            });

            undoBtn.addEventListener('click', undo);
            redoBtn.addEventListener('click', redo);
            newBtn.addEventListener('click', clearAllEditors);

            addCharacterBtn.addEventListener('click', () => {
                const currentText = characterEditor.value.trim();
                const newCharacterTemplate = `\n\n――――――――――\n*新しいキャラクター（名前：読み方、愛称）男女、歳\n*関係性\n*見た目、身体的特徴、服装\n*性格・裏性格\n*環境・生い立ち`;
                characterEditor.value = currentText + newCharacterTemplate;
                autoResizeTextArea(characterEditor);
                saveState();
                characterEditor.focus();
                characterEditor.setSelectionRange(characterEditor.value.length, characterEditor.value.length);
            });


            // --- カラムスライドのタッチイベントリスナー (スマートフォン用) ---
            columnsWrapper.addEventListener('touchstart', (e) => {
                if (window.innerWidth <= 768) {
                    touchStartX = e.touches[0].clientX; // スワイプ判定用に初期X座標を記録
                    isDragging = true;
                    columnsWrapper.style.transition = 'none'; // ドラッグ中はトランジションを無効にする (念のため)
                }
            }, { passive: false }); // passive: false を指定して preventDefault を許可

            columnsWrapper.addEventListener('touchmove', (e) => {
                if (window.innerWidth <= 768 && isDragging) {
                    // ここでカラムを動かす処理を削除 (すぐに切り替えるため)
                    // e.preventDefault(); // スクロールを防ぐ (必要な場合のみ)
                }
            }, { passive: false });

            columnsWrapper.addEventListener('touchend', (e) => { 
                if (window.innerWidth <= 768) {
                    isDragging = false;
                    touchEndX = e.changedTouches[0].clientX; // touchend時のX座標を記録
                    const diff = touchEndX - touchStartX; // スワイプ距離 (px)

                    // スワイプの閾値を画面幅の約15%に設定
                    const swipeThresholdPx = window.innerWidth * 0.15; 

                    let newColumnIndex = currentColumnIndex;
                    if (diff < -swipeThresholdPx) { // 左方向へのスワイプ (次のカラムへ)
                        newColumnIndex = Math.min(columns.length - 1, currentColumnIndex + 1);
                    } else if (diff > swipeThresholdPx) { // 右方向へのスワイプ (前のカラムへ)
                        newColumnIndex = Math.max(0, currentColumnIndex - 1);
                    } else {
                        // 閾値以下のスワイプの場合、現在表示中のカラムに留まる
                        newColumnIndex = currentColumnIndex;
                    }
                    
                    columnsWrapper.style.transition = 'none'; // アニメーションを完全に無効化
                    showColumn(newColumnIndex); // showColumn関数はvwで設定するので、ここでスナップ先を決定する
                }
            }, { passive: false });

            window.addEventListener('resize', () => {
                showColumn(currentColumnIndex); 
                autoResizeAllTextareas(); 
            });

            // 初期ロード処理
            loadState();
        });
    </script>
</body>
</html>

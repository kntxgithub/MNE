<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>漫画ネームエディタ</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            height: 100vh; /* ビューポートの高さに合わせる */
            display: flex;
            flex-direction: column;
            background-color: #e0e0e0;
            overflow: hidden; /* 全体スクロールは禁止 (カラムスライドのため) */
        }

        /* グローバルヘッダーは不要なため削除 */
        /* .global-header { ... } を削除 */

        /* PC版のデフォルトスタイル（4カラム表示） */
        .columns-wrapper { /* カラム全体を包むラッパー */
            flex-grow: 1;
            display: flex;
            width: 100%; /* PCでは100%幅 */
            padding-top: 0; /* グローバルヘッダーを削除したので0 */
            padding-bottom: 0; /* フッターナビを削除したので0 */
            box-sizing: border-box;
            overflow-x: auto; /* PCでは横スクロールを許可 */
            transition: none; /* PCではスライドアニメーションなし */
        }

        .column {
            width: 25vw; /* 各カラムの幅をビューポートの25%に */
            flex-shrink: 0; /* カラムが縮まないように */
            background-color: #fff;
            display: flex;
            flex-direction: column;
            border-right: 1px solid #eee; /* 各カラムの右側に境界線 */
            box-sizing: border-box;
            overflow: hidden; /* カラム自体はスクロールバーを持たない */
        }
        .column:last-child {
            border-right: none; /* 最後のカラムには境界線不要 */
        }


        /* 各カラムヘッダ内のボタンのスタイルを定義 */
        .column-header {
            background-color: #34495e;
            color: white;
            padding: 10px;
            font-weight: bold;
            text-align: center;
            flex-shrink: 0;
            position: sticky; /* カラム内でスクロールしても固定 */
            top: 0;
            z-index: 10;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .column-header .header-title {
            flex-shrink: 0;
            margin-right: auto;
        }

        .column-header .controls {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
            justify-content: flex-end;
            align-items: center;
        }

        .column-header .controls button {
            background-color: #6c757d;
            color: white;
            padding: 5px 10px;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 13px;
            transition: background-color 0.2s;
            margin-left: 5px;
        }

        .column-header .controls button#undoBtn,
        .column-header .controls button#redoBtn {
            background-color: #5a6268;
        }

        .column-header .controls button:hover {
            background-color: #5a6268;
        }
        
        .column-header .controls button#undoBtn:hover,
        .column-header .controls button#redoBtn:hover {
            background-color: #4a5157;
        }


        .column-header .controls button:disabled {
            background-color: #999;
            cursor: not-allowed;
        }

        .column-content {
            flex-grow: 1;
            overflow-y: auto; /* この領域でスクロールする */
            padding: 10px;
            /*display: flex;*/
            flex-direction: column;
            gap: 10px;
        }

        textarea {
            width: 100%;
            height: auto; /* 自動リサイズのためにautoに */
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: 'Meiryo', 'Hiragino Kaku Gothic ProN', 'BIZ UDPGothic', sans-serif;
            font-size: 1em;
            line-height: 1.6;
            resize: none; /* デフォルトはなし */
            box-sizing: border-box;
            min-height: 50px;
            overflow: hidden; /* スクロールバーは表示しない */
        }

        .main-textarea {
            flex-grow: 1;
            min-height: 150px;
            resize: vertical; /* メインエディタもマニュアルリサイズ可能に */
        }

        .outline-textarea {
            min-height: 50px;
            max-height: none; /* max-heightを削除 (自動で伸びる) */
            resize: vertical; 
        }

        .character-textarea { 
            min-height: 70vh; 
            max-height: none; /* max-heightを削除 (自動で伸びる) */
            resize: vertical; 
            overflow-y: auto; /* キャラクターは内容が多いのでスクロール許可 */
        }
        
        /* シーン/ページ/セリフの動的表示用スタイル */
        .item-wrapper {
            display: flex;
            align-items: flex-start;
            padding: 2px 0;
            border-bottom: 1px dashed #eee;
            margin-bottom: 2px;
            font-family: 'Meiryo', 'Hiragino Kaku Gothic ProN', 'BIZ UDPGothic', sans-serif;
            font-size: 0.95em;
            line-height: 1.6;
            box-sizing: border-box;
            flex-shrink: 0;
            word-wrap: break-word;
            white-space: pre-wrap;
        }
        .item-wrapper textarea {
            flex-grow: 1;
            margin: 0;
            padding: 0;
            border: none;
            background: transparent;
            font-size: 1em;
            line-height: inherit;
            resize: none;
            overflow: hidden; /* スクロールバーは表示しない */
            height: auto;
            box-sizing: border-box;
        }

        /* シーンのtextarea */
        .scene-item-container textarea {
            width: 100%;
            border: 1px solid #ddd;
            border-top: none;
            padding: 5px;
            box-sizing: border-box;
            background-color: white;
            border-radius: 0;
            padding: 5px;
            overflow: hidden; 
            min-height: 40px; /* シーン説明の最小の高さ */
            max-height: none; 
            resize: none; 
            height: auto; 
        }
        
        /* ページとセリフのtextarea */
        .page-item-container textarea {/*,}.dialogue-content textarea { */
            width: 100%;
            border: 1px solid #ddd;
            padding: 5px;
            box-sizing: border-box;
            background-color: white;
            border-radius: 0;
            overflow: hidden; 
            min-height: 40px; /* ページ説明・セリフの最小の高さ */
            max-height: none; 
            resize: none; 
            height: auto; 
        }


        .item-wrapper .content-display {
            flex-grow: 1;
            margin: 0;
            padding: 0;
            border: none;
            background: transparent;
            font-size: 1em;
            line-height: inherit;
            white-space: pre-wrap;
            word-wrap: break-word;
            min-height: 1.6em;
        }

        .line-numbers {
            width: 35px;
            text-align: right;
            padding-right: 5px;
            color: #aaa;
            font-size: 0.8em;
            flex-shrink: 0;
            user-select: none;
        }

        /* ファイルドロップ時のスタイル (このレイアウトでは直接見えないかもしれない) */
        body.drag-over .column.main-column {
            box-shadow: 0 0 15px rgba(0, 123, 255, 0.5);
            border: 2px dashed #007bff;
        }

        /* シーンカラム内の追加ボタン */
        .add-button-container {
            text-align: center;
            margin: 0;
            padding-top: 5px;
            border-top: 1px dashed #eee;
            margin-bottom: 10px;
        }
        .add-button-container button {
            background-color: #17A2B8;
            color: white;
            padding: 5px 10px;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.9em;
            width: 100%;
            box-sizing: border-box;
            margin: 0 auto;
            display: block;
        }
        .add-button-container button:hover {
            background-color: #138496;
        }

        /* シーンアイテムの具体的なスタイル */
        .scene-item-container {
            border: 1px solid #ccc;
            padding: 0px;
            margin-bottom: 10px;
            border-radius: 5px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
            display: flex;
            flex-direction: column;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        }
        /* アクティブな要素の強調表示 */
        .scene-item-container.active,
        .page-item-container.active,
        .dialogue-content.active,
        .character-item-container.active { 
            box-shadow: 0 0 8px 3px rgba(0, 123, 255, 0.5);
            border-color: #007bff;
            transform: scale(1.01);
        }

        .page-item-container {
            border: 1px solid #ccc;
            padding: 0px;
            margin: 0;
            margin-bottom: 5px;
            border-radius: 5px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
            cursor: pointer;
            transition: background-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        }

        /* シーンの背景色ローテーション用クラス */
        .scene-color-0 { background-color: #e0f7fa; }
        .scene-color-1 { background-color: #f0f4c3; }
        .scene-color-2 { background-color: #ffe0b2; }
        .scene-color-3 { background-color: #e1bee7; }
        .scene-color-4 { background-color: #b3e5fc; }

        /* セリフ表示部分のスタイル */
        .serif-page-group-container {
            border: 1px solid #dcdcdc;
            border-radius: 5px;
            margin-bottom: 15px;
            padding: 10px;
            background-color: #FFEDD5;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
            box-sizing: border-box;
            cursor: pointer;
        }


        .dialogue-content {
            margin-bottom: 8px;
            border-radius: 5px;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            box-sizing: border-box;
            cursor: pointer;
            transition: none;
            flex-grow: 1;
            white-space: pre-wrap;
            word-wrap: break-word;
            font-size: 0.95em;
            line-height: 1.6;
            border-left: 3px solid #f9ab00;
            padding: 10px;
            font-style: italic;
            color: #333;
            background-color: #fffbf0;
            border-radius: 0px;
            width: 100%;
        }
        /* 個別のセリフtextareaのスタイル調整 */
        /*.dialogue-content textarea {*/
            /*padding: 5px;*/
            /*border: 1px solid #ddd;*/
            /*border-radius: 3px;*/
            /*font-style:normal;*/ /* 親のitalicを打ち消す */
            /*background-color: white;*/
            /*min-height: 30px;*/ /* セリフtextareaの最小の高さ */
        /*}*/


        .scene-item-header, .page-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 10px; /* シーンとページで共通のパディング */
            flex-shrink: 0;
        }

        .scene-title-badge {
            background-color: #007bff;
            color: white;
            padding: 3px 8px;
            border-radius: 4px;
            font-weight: bold;
            font-size: 1.0em;
            display: inline-block;
        }

        .page-title-badge {
            background-color: #007bff;
            color: white;
            padding: 3px 8px;
            border-radius: 4px;
            font-weight: bold;
            font-size: 1.0em;
            display: inline-block;
        }

        .scene-item-header .delete-scene-btn, .page-item-header .delete-page-btn {
            background-color: #dc3545;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.8em;
            transition: background-color 0.2s;
        }

        .scene-item-header .delete-scene-btn:hover, .page-item-header .delete-page-btn:hover {
            background-color: #c82333;
        }

        .section-container {
            border: 1px solid #ccc;
            border-radius: 5px;
            margin-bottom: 10px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
            background-color: #f8f8f8;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .section-header {
            background-color: #f0f0f0;
            padding: 8px 10px;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: bold;
            flex-shrink: 0;
            cursor: pointer;
        }

        .section-header h3 {
            margin: 0;
            font-size: 1em;
            color: #333;
            flex-grow: 1;
        }

        .toggle-btn, .add-character-btn {
            background-color: #6c757d;
            color: white;
            padding: 4px 8px;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.8em;
            transition: background-color 0.2s;
            margin-left: 5px;
        }

        .toggle-btn:hover, .add-character-btn:hover {
            background-color: #5a6268;
        }

        .section-content {
            padding: 10px;
            transition: max-height 0.3s ease-out, opacity 0.3s ease-out, padding 0.3s ease-out;
            overflow-y: auto; 
            max-height: none; 
            opacity: 1;
            box-sizing: border-box;
        }

        .section-content.hidden {
            max-height: 0 !important;
            padding-top: 0;
            padding-bottom: 0;
            opacity: 0;
            visibility: hidden;
        }

        /* .character-textarea, .outline-textarea, .main-textarea は個別の max-height を持つ */
        .character-textarea, .outline-textarea, .main-textarea {
            border: none;
            min-height: 50px;
            background-color: white;
            border-radius: 0;
            padding: 5px;
        }

        .main-textarea {
            min-height: 150px;
        }

        /* 個別のシーン内でページを追加するためのボタン */
        .add-page-to-scene-btn {
            background-color: #34495e; /* 紺色に変更 */
            color: white;
            padding: 5px 10px;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.9em;
            width: calc(100% - 20px); /* Padding分を考慮 */
            box-sizing: border-box;
            margin: 10px; /* シーンアイテムの下に少しマージン */
            display: block;
            text-align: center;
        }
        .add-page-to-scene-btn:hover {
            background-color: #2c3e50; /* ホバー時の色 */
        }


        /* --- スマートフォン対応のためのメディアクエリ --- */
        @media (max-width: 768px) {
            body {
                overflow-y: hidden; /* 全体スクロールを禁止 (横スライドのため) */
            }

            .columns-wrapper {
                width: 400vw; /* 4カラム分の幅 */
                transform: translateX(0vw); /* 初期表示はJSで設定 */
                transition: transform 0.3s ease-in-out; /* スライドアニメーション */
                padding-top: 0; /* グローバルヘッダーを削除したので0 */
                padding-bottom: 0; /* フッターナビを削除したので0 */
                box-sizing: border-box;
                overflow-x: hidden; /* 横スクロール禁止 (JSで制御するため) */
            }

            .column {
                width: 100vw; /* 各カラムの幅をビューポートの幅に */
                flex-shrink: 0; /* カラムが縮まないように */
                border-right: none; /* スマホではカラム間の境界線は不要 */
            }

            .column-header {
                flex-direction: column;
                align-items: flex-start;
                padding: 8px;
            }

            .column-header .header-title {
                margin-right: 0;
                margin-bottom: 5px;
            }

            .column-header .controls {
                width: 100%;
                justify-content: space-around;
                gap: 5px;
            }

            .column-header .controls button {
                flex-grow: 1;
                margin-left: 0;
                padding: 8px 5px;
                font-size: 1em;
            }

            .column-content {
                padding: 8px;
            }

            /* スマホ時のsection-contentのmax-heightも調整 */
            .section-content {
                max-height: none; /* スマホでも内部のtextareaがスクロールするように */
            }
        }

        @media (max-width: 480px) {
            .column-header .controls button {
                font-size: 0.9em;
                padding: 6px 3px;
            }

            .section-header h3 {
                font-size: 0.9em;
            }
            .toggle-btn, .add-character-btn {
                font-size: 0.7em;
                padding: 3px 6px;
            }
            
            textarea {
                font-size: 0.9em;
            }
            .line-numbers {
                width: 25px;
                font-size: 0.7em;
            }

            .section-content {
                max-height: none; /* スマホでも内部のtextareaがスクロールするように */
            }
        }
    </style>
</head>
<body>
    <div class="columns-wrapper" id="columnsWrapper">
        <div class="column main-column" data-column-id="main">
            <div class="column-header">
                <span class="header-title">メイン</span>
                <div class="controls">
                    <button id="newBtn">新規</button>
                    <button id="openBtn">開く</button>
                    <input type="file" id="fileInput" style="display: none;">
                    <button id="saveBtn">保存</button>
                    <button id="saveAsBtn">別名保存</button>
                    <button id="undoBtn">↶</button>
                    <button id="redoBtn">↷</button>
                </div>
            </div>
            <div class="column-content">
                <div class="section-container" id="outlineSection">
                    <div class="section-header">
                        <h3>アウトライン</h3>
                        <button class="toggle-btn" data-target="outlineContent">隠す</button>
                    </div>
                    <div class="section-content" id="outlineContent">
                        <textarea id="outlineEditor" class="outline-textarea" placeholder="ここに物語のアウトラインを記述してください。"></textarea>
                    </div>
                </div>
                
                <div class="section-container" id="characterSection">
                    <div class="section-header">
                        <h3>キャラクター</h3>
                        <div class="controls">
                            <button class="add-character-btn" id="addCharacterBtn">追加</button>
                            <button class="toggle-btn" data-target="characterContent">隠す</button>
                        </div>
                    </div>
                    <div class="section-content" id="characterContent">
                        <textarea id="characterEditor" class="character-textarea"></textarea>
                    </div>
                </div>

                <div class="section-container" id="mainEditorSection">
                    <div class="section-header">
                        <h3>ネーム本体 (XML)</h3>
                        <button class="toggle-btn" data-target="mainEditorContent">隠す</button>
                    </div>
                    <div class="section-content" id="mainEditorContent">
                        <textarea id="mainEditor" class="main-textarea" placeholder="XML形式でネームを記述してください。例：
<root><シーン><シーン説明>新しいシーン</シーン説明><ページ><ページ説明>新しいページ</ページ説明><セリフ>セリフA</セリフ></ページ></シーン></root>">
</textarea>
                    </div>
                </div>
            </div>
        </div>

        <div class="column scene-column" data-column-id="scene">
            <div class="column-header">
                <span class="header-title">シーン</span>
                <div class="controls">
                    <button id="addSceneBtn">シーン追加</button>
                </div>
            </div>
            <div class="column-content" id="sceneContent">
                <p>メインエディタの内容からシーンを抽出します。</p>
            </div>
        </div>

        <div class="column page-column" data-column-id="page">
            <div class="column-header">
                <span class="header-title">ページ</span>
            </div>
            <div class="column-content" id="pageContent">
                <p>メインエディタの内容からページを抽出します。</p>
            </div>
        </div>

        <div class="column serif-column" data-column-id="serif">
            <div class="column-header">
                <span class="header-title">セリフ</span>
                <div class="controls">
                    <button id="exportDialogueBtn">エクスポート</button>
                </div>
            </div>
            <div class="column-content" id="dialogueContent">
                <p>メインエディタの内容からセリフを抽出します。</p>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const outlineEditor = document.getElementById('outlineEditor');
            const characterEditor = document.getElementById('characterEditor');
            const mainEditor = document.getElementById('mainEditor');

            const sceneContentDiv = document.getElementById('sceneContent');
            const pageContentDiv = document.getElementById('pageContent');
            const dialogueContentDiv = document.getElementById('dialogueContent');

            const newBtn = document.getElementById('newBtn');
            const openBtn = document.getElementById('openBtn');
            const saveBtn = document.getElementById('saveBtn');
            const saveAsBtn = document.getElementById('saveAsBtn');
            const fileInput = document.getElementById('fileInput');
            const undoBtn = document.getElementById('undoBtn');
            const redoBtn = document.getElementById('redoBtn');

            const outlineContentDiv = document.getElementById('outlineContent');
            const characterContentDiv = document.getElementById('characterContent');
            const mainEditorContentDiv = document.getElementById('mainEditorContent');

            const toggleButtons = document.querySelectorAll('.toggle-btn');

            const addSceneBtn = document.getElementById('addSceneBtn'); 
            const addCharacterBtn = document.getElementById('addCharacterBtn');
            const exportDialogueBtn = document.getElementById('exportDialogueBtn');

            const columnsWrapper = document.getElementById('columnsWrapper');
            
            let currentFileName = '新規ネーム.txt';
            let history = [''];
            let historyIndex = 0;
            const MAX_HISTORY = 100;
            let updateTimeout;
            const DEBOUNCE_DELAY = 300; 
            let currentXmlDoc = null;
            let currentFileHandle = null;

            const xmlParser = new DOMParser();
            const xmlSerializer = new XMLSerializer();

            let nodeIdCounter = 0; 

            // XMLノードとDOM要素の関連付け用マップ
            const sceneNodeIdToDomElementMap = new Map();
            const pageNodeIdToDomElementMap = new Map();
            const sceneNodeIdToFirstPageDomElementMap = new Map();
            const dialogueNodeIdToDomElementMap = new Map(); 

            let activeSceneElement = null;
            let activePageElement = null;
            let activeDialogueElement = null; // 個別のセリフ要素

            // --- カラム表示制御用の変数 ---            
            let currentColumnIndex = 0; // 0:メイン, 1:シーン, 2:ページ, 3:セリフ
            const columns = document.querySelectorAll('.column');
            let touchStartX = 0;
            let touchEndX = 0;
            // currentTranslateX を touchstart イベント外で宣言し、値が保持されるようにする
            let currentTranslateX = 0; 
            let isSwiping = false; // スワイプ中かどうかのフラグ

            function showColumn(index) {
                if (index < 0 || index >= columns.length) return;
                currentColumnIndex = index;

                if (window.innerWidth <= 768) {
                    // PC表示ではtranslateXをリセットし、transitionを無効化
                    columnsWrapper.style.transform = `translateX(-${index * 100}vw)`;
                    columnsWrapper.style.transition = 'transform 0.3s ease-out'; // スナップ時のアニメーション
                    // columnsWrapper.style.scrollBehavior = 'auto'; // translateXで制御するため不要
                } else {
                    columnsWrapper.style.transform = `translateX(0)`; // PCではtranslateXを0に戻す
                    columnsWrapper.style.transition = 'none'; // PCではスライドアニメーションなし
                    columnsWrapper.style.scrollBehavior = 'smooth'; 
                    // PC版ではcolumnsWrapperのoverflow-x: autoを活かすためscrollLeftでスクロール
                    columnsWrapper.scrollLeft = columns[index].offsetLeft;
                }
            }


            function saveState() {
                const state = {
                    outlineContent: outlineEditor.value,
                    characterContent: characterEditor.value,
                    mainContent: mainEditor.value,
                    fileName: currentFileName,
                    history: history,
                    historyIndex: historyIndex,
                    outlineHidden: outlineContentDiv.classList.contains('hidden'),
                    characterHidden: characterContentDiv.classList.contains('hidden'),
                    mainEditorHidden: mainEditorContentDiv.classList.contains('hidden'),
                    currentColumnIndex: currentColumnIndex 
                };
                localStorage.setItem('comicNameEditorState', JSON.stringify(state));
                console.log('State saved.');
            }

            function clearAllEditors() {
                outlineEditor.value = '';
                characterEditor.value = `*主人公（名前：読み方、愛称）男女、歳
*関係性
*見た目、身体的特徴、服装
*性格・裏性格
*環境・生い立ち
――――――――――
*ヒロイン（名前：読み方、愛称）男女、歳
*関係性
*見た目、身体的特徴、服装
*性格・裏性格
*環境・生い立ち
――――――――――
*ライバル（名前：読み方、愛称）男女、歳
*関係性
*見た目、身体的特徴、服装
*性格・裏性格
*環境・生い立ち`;

                // 新規作成時のXML初期値に、空のセリフ要素も含むように変更
                mainEditor.value = `<root><シーン><シーン説明>新しいシーン</シーン説明><ページ><ページ説明>新しいページ</ページ説明><セリフ></セリフ></ページ></シーン></root>`;
                currentFileName = '新規ネーム.txt';
                currentFileHandle = null;
                history = [mainEditor.value];
                historyIndex = 0;
                localStorage.removeItem('comicNameEditorState');
                
                setSectionVisibility(outlineContentDiv, false);
                setSectionVisibility(characterContentDiv, false);
                setSectionVisibility(mainEditorContentDiv, true);

                currentColumnIndex = 0; 
                showColumn(currentColumnIndex); 
                updateUIImmediate();
                alert('新しいネームを開始しました。');
            }


            function loadState() {
                const savedState = localStorage.getItem('comicNameEditorState');
                if (savedState) {
                    const state = JSON.parse(savedState);
                    outlineEditor.value = state.outlineContent || '';
                    characterEditor.value = state.characterContent || '';
                    mainEditor.value = state.mainContent || '';
                    currentFileName = state.fileName || '新規ネーム.txt';
                    history = state.history || [''];
                    historyIndex = state.historyIndex || 0;

                    setSectionVisibility(outlineContentDiv, state.outlineHidden || false);
                    setSectionVisibility(characterContentDiv, state.characterHidden || false);
                    setSectionVisibility(mainEditorContentDiv, state.mainEditorHidden || false);
                    
                    currentColumnIndex = state.currentColumnIndex !== undefined ? state.currentColumnIndex : 0; 
                    console.log('State loaded.');
                } else {
                    outlineEditor.value = '';
                    characterEditor.value = `*主人公（名前：読み方、愛称）男女、歳
*関係性
*見た目、身体的特徴、服装
*性格・裏性格
*環境・生い立ち
――――――――――
*ヒロイン（名前：読み方、愛称）男女、歳
*関係性
*見た目、身体的特徴、服装
*性格・裏性格
*環境・生い立ち
――――――――――
*ライバル（名前：読み方、愛称）男女、歳
*関係性
*見た目、身体的特徴、服装
*性格・裏性格
*環境・生い立ち`;

                    // 初期XML値もセリフが空でもタグがあるように変更
mainEditor.value = `<root><シーン><シーン説明>新しいシーン</シーン説明><ページ><ページ説明>新しいページ</ページ説明><セリフ></セリフ></ページ></シーン></root>`;
                    history = [mainEditor.value];
                    historyIndex = 0;

                    setSectionVisibility(outlineContentDiv, false);
                    setSectionVisibility(characterContentDiv, false);
                    setSectionVisibility(mainEditorContentDiv, true);
                    currentColumnIndex = 0; 
                }
                showColumn(currentColumnIndex); 
                updateUIImmediate();
                autoResizeAllTextareas();
            }

            function setSectionVisibility(contentDiv, isHidden) {
                const toggleBtn = contentDiv.previousElementSibling.querySelector('.toggle-btn');
                const addCharBtn = contentDiv.previousElementSibling.querySelector('.add-character-btn');
                if (isHidden) {
                    contentDiv.classList.add('hidden');
                    if (toggleBtn) toggleBtn.textContent = '開く';
                    if (addCharBtn) addCharBtn.style.display = 'none';
                } else {
                    contentDiv.classList.remove('hidden');
                    if (toggleBtn) toggleBtn.textContent = '隠す';
                    if (addCharBtn) addCharBtn.style.display = 'inline-block';
                }
                if (!isHidden && contentDiv.querySelector('textarea')) { 
                    autoResizeTextArea(contentDiv.querySelector('textarea'));
                }
            }

            function updateUI() {
                clearTimeout(updateTimeout);
                updateTimeout = setTimeout(() => {
                    updateUndoRedoButtons();
                    syncColumnsFromMainEditor();
                    saveState();
                    console.log('UI updated and State saved (debounced).');
                }, DEBOUNCE_DELAY);
            }

            function updateUIImmediate() {
                updateUndoRedoButtons();
                syncColumnsFromMainEditor();
                saveState();
                console.log('UI updated and State saved (immediate).');
            }

            function updateUndoRedoButtons() {
                undoBtn.disabled = historyIndex === 0;
                redoBtn.disabled = historyIndex === history.length - 1;
            }

            function addToHistory(content) {
                if (history.length > 0 && history[historyIndex] === content) {
                    return;
                }
                if (historyIndex < history.length - 1) {
                    history = history.slice(0, historyIndex + 1);
                }
                history.push(content);
                if (history.length > MAX_HISTORY) {
                    history.shift();
                } else {
                    historyIndex++;
                }
                updateUndoRedoButtons();
            }

            function undo() {
                if (historyIndex > 0) {
                    historyIndex--;
                    mainEditor.value = history[historyIndex];
                    updateUIImmediate();
                }
            }

            function redo() {
                if (historyIndex < history.length - 1) {
                    historyIndex++;
                    mainEditor.value = history[historyIndex];
                    updateUIImmediate();
                }
            }

            openBtn.addEventListener('click', async () => {
                try {
                    const [fileHandle] = await window.showOpenFilePicker({
                        types: [
                            {
                                description: 'Text Files',
                                accept: {
                                    'text/plain': ['.txt'],
                                },
                            },
                        ],
                    });
                    const file = await fileHandle.getFile();
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        extractAndSetSeparateContents(event.target.result);
                        currentFileName = file.name;
                        currentFileHandle = fileHandle;
                        history = [mainEditor.value];
                        historyIndex = 0;
                        updateUIImmediate();
                    };
                    reader.onerror = () => {
                        alert('ファイルの読み込みに失敗しました。');
                    };
                    reader.readAsText(file);
                } catch (err) {
                    if (err.name === 'AbortError') {
                        console.log('File picker was cancelled.');
                    } else {
                        console.error('Error opening file:', err);
                        alert('ファイルのオープン中にエラーが発生しました。');
                    }
                }
            });

            async function saveContentToDisk(handle) {
                const xmlContent = mainEditor.value;
                const fullContentToSave = `[アウトライン:]\n${outlineEditor.value}\n\n` +
                                          `[キャラクター:]\n${characterEditor.value}\n\n` +
                                          `[ネーム本体(XML):]\n${xmlContent}\n\n` +
                                          `[セリフ一覧(今後廃止):]\n`;

                try {
                    const writable = await handle.createWritable();
                    await writable.write(fullContentToSave);
                    await writable.close();
                    alert(`ファイルを保存しました: ${currentFileName}`);
                } catch (err) {
                    console.error('Error writing to file:', err);
                    alert('ファイルの書き込み中にエラーが発生しました。');
                }
            }

            saveBtn.addEventListener('click', async () => {
                let handle = currentFileHandle;
                if (!handle) {
                    try {
                        handle = await window.showSaveFilePicker({
                            types: [{
                                    description: 'Text Files',
                                    accept: {
                                        'text/plain': ['.txt'],
                                    },
                                },],
                            suggestedName: currentFileName
                        });
                        currentFileHandle = handle;
                        currentFileName = handle.name;
                    } catch (err) {
                        if (err.name === 'AbortError') {
                            console.log('Save operation was cancelled.');
                            return; // Exit if cancelled
                        } else {
                            console.error('Error opening file picker for save:', err);
                            alert('ファイルの保存中にエラーが発生しました。');
                            return; // Exit on error
                        }
                    }
                }
                if (handle) { // Only proceed if a handle is obtained
                    await saveContentToDisk(handle);
                }
            });

            saveAsBtn.addEventListener('click', async () => {
                try {
                    const handle = await window.showSaveFilePicker({
                        types: [{
                                description: 'Text Files',
                                accept: {
                                    'text/plain': ['.txt'],
                                },
                            },],
                        suggestedName: currentFileName
                    });
                    currentFileHandle = handle;
                    currentFileName = handle.name;
                    await saveContentToDisk(handle);
                } catch (err) {
                    if (err.name === 'AbortError') {
                        console.log('Save As operation was cancelled.');
                    } else {
                        console.error('Error opening file picker for save as:', err);
                        alert('ファイルの別名保存中にエラーが発生しました。');
                    }
                }
            });

            const mainColumn = document.querySelector('.column.main-column');
            document.body.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.stopPropagation();
                if (window.innerWidth > 768) {
                    document.body.classList.add('drag-over');
                }
            });

            document.body.addEventListener('dragleave', (e) => {
                if (window.innerWidth > 768) {
                    if (!mainColumn.contains(e.relatedTarget) && e.relatedTarget !== null) {
                        document.body.classList.remove('drag-over');
                    }
                }
            });

            mainColumn.addEventListener('drop', async (e) => {
                e.preventDefault();
                document.body.classList.remove('drag-over');

                const file = e.dataTransfer.files[0];
                if (file && file.type === 'text/plain') {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        extractAndSetSeparateContents(event.target.result);
                        currentFileName = file.name;
                        currentFileHandle = null;
                        history = [mainEditor.value];
                        historyIndex = 0;
                        updateUIImmediate();
                    };
                    reader.onerror = () => {
                        alert('ファイルの読み込みに失敗しました。');
                    };
                    reader.readAsText(file);
                }
            });

            function extractAndSetSeparateContents(fullText) {
                const extracted = { outline: '', character: '', main: '' };

                const outlineMatch = fullText.match(/\[アウトライン:\]\n([\s\S]*?)(?=\n*\[キャラクター:\]|\n*\[ネーム本体\(XML\):\]|\n*\[セリフ一覧\(今後廃止\):\]|$)/);
                if (outlineMatch) extracted.outline = outlineMatch[1].trim();

                const characterMatch = fullText.match(/\[キャラクター:\]\n([\s\S]*?)(?=\n*\[ネーム本体\(XML\):\]|\n*\[セリフ一覧\(今後廃止\):\]|$)/);
                if (characterMatch) extracted.character = characterMatch[1].trim();

                const mainXmlMatch = fullText.match(/\[ネーム本体\(XML\):\]\n([\s\S]*?)(?=\n*\[セリフ一覧\(今後廃止\):\]|$)/);
                if (mainXmlMatch) extracted.main = mainXmlMatch[1].trim();

                outlineEditor.value = extracted.outline;
                characterEditor.value = extracted.character;
                mainEditor.value = extracted.main;
            }


            function syncColumnsFromMainEditor() {
                const mainText = mainEditor.value;

                // マップをクリアして再構築
                sceneNodeIdToDomElementMap.clear();
                pageNodeIdToDomElementMap.clear();
                sceneNodeIdToFirstPageDomElementMap.clear();
                dialogueNodeIdToDomElementMap.clear();
                nodeIdCounter = 0; // ノードIDカウンターをリセット

                try {
                    let textToParse = mainText.trim();
                    if (!textToParse.startsWith('<root>') || !textToParse.endsWith('</root>')) {
                        // rootタグがない場合でもパースを試みるが、エラーになる可能性を考慮
                        textToParse = `<root>${textToParse}</root>`; 
                    }
                    currentXmlDoc = xmlParser.parseFromString(textToParse, 'application/xml');

                    const parserError = currentXmlDoc.querySelector('parsererror');
                    if (parserError) {
                        console.error('XML Parsing Error:', parserError.textContent);
                        const errorMessage = '<p style="color: red;">XMLパースエラー: メインエディタの記述を確認してください。</p>';
                        sceneContentDiv.innerHTML = errorMessage;
                        pageContentDiv.innerHTML = errorMessage;
                        dialogueContentDiv.innerHTML = errorMessage;
                        return;
                    }
                }
                catch (e) {
                    console.error('Failed to parse XML:', e);
                    const errorMessage = '<p style="color: red;">XMLパースに失敗しました。</p>';
                    sceneContentDiv.innerHTML = errorMessage;
                    pageContentDiv.innerHTML = errorMessage;
                    dialogueContentDiv.innerHTML = errorMessage;
                    return;
                }

                const scenes = currentXmlDoc.querySelectorAll('シーン');
                const sceneItems = [];
                scenes.forEach((sceneElement, index) => {
                    const nodeId = `node-${nodeIdCounter++}`; 
                    sceneItems.push({
                        title: `シーン${index + 1}`,
                        text: sceneElement.querySelector('シーン説明')?.textContent || '',
                        nodeId: nodeId, 
                        rawNode: sceneElement, 
                        sceneIndex: index
                    });
                });
                renderSceneColumnContent(sceneContentDiv, sceneItems);

                // --- ページカラムの描画 ---
                pageContentDiv.innerHTML = '';
                let globalPageIndex = 1;
                if (scenes.length === 0) {
                    const p = document.createElement('p');
                    p.textContent = `メインエディタの内容からページを抽出します。`;
                    pageContentDiv.appendChild(p);
                } else {
                    scenes.forEach((sceneElement, sceneIndex) => {
                        const sceneNodeIdForDom = [...sceneNodeIdToDomElementMap.keys()].find(key => sceneNodeIdToDomElementMap.get(key).xmlNode === sceneElement);
                        const sceneTitle = `シーン${sceneIndex + 1}`;
                        const sceneColorClass = `scene-color-${sceneIndex % 5}`; 

                        const pagesInScene = sceneElement.querySelectorAll('ページ');
                        
                        if (pagesInScene.length === 0) {
                            const p = document.createElement('p');
                            p.textContent = `このシーンにはページがありません。`;
                            p.style.fontSize = '0.9em';
                            p.style.color = '#777';
                            p.style.marginLeft = '10px';
                            p.style.marginBottom = '10px';
                            pageContentDiv.appendChild(p);
                        } 
                        
                        pagesInScene.forEach((pageElement) => {
                            const nodeId = `node-${nodeIdCounter++}`;
                            
                            const pageItemContainer = document.createElement('div');
                            pageItemContainer.classList.add('page-item-container');
                            pageItemContainer.setAttribute('data-node-id', nodeId); 
                            pageItemContainer.xmlNode = pageElement; // XMLノードをDOM要素に紐付け
                            pageItemContainer.setAttribute('data-parent-scene-id', sceneNodeIdForDom); // 親シーンのDOM IDを保持
                            pageItemContainer.classList.add(sceneColorClass); 
                            pageItemContainer.addEventListener('click', (event) => {
                                setActiveElement(pageItemContainer, 'page');
                                showColumn(2); 
                                if (window.innerWidth > 768) { 
                                    pageItemContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });
                                }
                            });

                            const pageHeader = document.createElement('div');
                            pageHeader.classList.add('page-item-header');
                            const pageTitleBadge = document.createElement('span');
                            pageTitleBadge.classList.add('page-title-badge');
                            pageTitleBadge.textContent = `ページ${globalPageIndex}`;
                            pageHeader.appendChild(pageTitleBadge);

                            const deleteButton = document.createElement('button');
                            deleteButton.classList.add('delete-page-btn');
                            deleteButton.textContent = '削除';
                            deleteButton.addEventListener('click', (e) => {
                                e.stopPropagation(); 
                                deletePage(pageItemContainer.xmlNode, `ページ${globalPageIndex}`);
                            });
                            pageHeader.appendChild(deleteButton);
                            pageItemContainer.appendChild(pageHeader);

                            const itemTextArea = document.createElement('textarea');
                            itemTextArea.value = pageElement.querySelector('ページ説明')?.textContent || '';
                            itemTextArea.classList.add('page-text'); 
                            itemTextArea.placeholder = 'ページ内の説明やセリフ';
                            itemTextArea.addEventListener('input', (e) => {
                                autoResizeTextArea(e.target);
                                updatePageContentInXml(pageItemContainer.xmlNode, e.target.value);
                            });
                            itemTextArea.addEventListener('change', () => { 
                                updateUIImmediate(); 
                            });
                            pageItemContainer.appendChild(itemTextArea);
                            autoResizeTextArea(itemTextArea); 
                            
                            pageContentDiv.appendChild(pageItemContainer);
                            pageNodeIdToDomElementMap.set(nodeId, pageItemContainer);

                            if (!sceneNodeIdToFirstPageDomElementMap.has(sceneNodeIdForDom)) {
                                sceneNodeIdToFirstPageDomElementMap.set(sceneNodeIdForDom, pageItemContainer);
                            }
                            globalPageIndex++;
                        });
                        
                        const addPageButtonForScene = document.createElement('button');
                        addPageButtonForScene.classList.add('add-page-to-scene-btn');
                        addPageButtonForScene.textContent = `「${sceneTitle}」にページを追加`;
                        addPageButtonForScene.setAttribute('data-scene-node-id', sceneNodeIdForDom); 
                        addPageButtonForScene.xmlNode = sceneElement; 
                        addPageButtonForScene.addEventListener('click', (e) => {
                            e.stopPropagation(); 
                            addPageToSpecificScene(sceneElement); 
                        });
                        pageContentDiv.appendChild(addPageButtonForScene);
                    });
                }
                
                // --- セリフカラムの描画 ---
                dialogueContentDiv.innerHTML = ''; 
                if (scenes.length === 0) {
                    const p = document.createElement('p');
                    p.textContent = `メインエディタの内容からセリフを抽出します。`;
                    dialogueContentDiv.appendChild(p);
                } else {
                    scenes.forEach((sceneElement) => { 
                        const pagesInScene = sceneElement.querySelectorAll('ページ');
                        
                        pagesInScene.forEach((pageElement) => { 
                            const dialoguesInPage = pageElement.querySelectorAll('セリフ');
                            // XMLノードとDOM要素の関連付けのために、pageElementのnodeIdを取得
                            const pageNodeIdForDom = [...pageNodeIdToDomElementMap.keys()].find(key => pageNodeIdToDomElementMap.get(key).xmlNode === pageElement);

                            if (dialoguesInPage.length > 0) {

                                dialoguesInPage.forEach((dialogueElement) => {
                                    const nodeId = `node-${nodeIdCounter++}`;
                                    const dialogueContentDivItem = document.createElement('div');
                                    dialogueContentDivItem.classList.add('dialogue-content');
                                    dialogueContentDivItem.setAttribute('data-node-id', nodeId); 
                                    dialogueContentDivItem.xmlNode = dialogueElement; 
                                    dialogueContentDivItem.setAttribute('data-parent-page-id', pageNodeIdForDom); 
                                    dialogueContentDivItem.addEventListener('click', (event) => {
                                        setActiveElement(dialogueContentDivItem, 'dialogue');
                                        showColumn(3); 
                                        if (window.innerWidth > 768) { 
                                            dialogueContentDivItem.scrollIntoView({ behavior: 'smooth', block: 'center' });
                                        }
                                    });

                                    const itemTextArea = document.createElement('textarea');
                                    itemTextArea.value = dialogueElement.textContent; 
                                    itemTextArea.classList.add('serif-text'); 
                                    itemTextArea.placeholder = 'セリフを入力';
                                    itemTextArea.addEventListener('input', (e) => {
                                        autoResizeTextArea(e.target);
                                        updateDialogueContentInXml(dialogueContentDivItem.xmlNode, e.target.value);
                                    });
                                    itemTextArea.addEventListener('change', () => { 
                                        updateUIImmediate(); 
                                    });
                                    dialogueContentDivItem.appendChild(itemTextArea);
                                    autoResizeTextArea(itemTextArea); 
                                    
                                    dialogueContentDiv.appendChild(dialogueContentDivItem); 
                                    dialogueNodeIdToDomElementMap.set(nodeId, dialogueContentDivItem);
                                });
                            }
                        });
                    });
                }
                highlightActiveElements();
                autoResizeAllTextareas(); 
            }

            function renderSceneColumnContent(container, sceneItems) {
                container.innerHTML = '';
                if (sceneItems.length === 0) {
                    const p = document.createElement('p');
                    p.textContent = `メインエディタの内容からシーンを抽出します。`;
                    container.appendChild(p);
                    return;
                }

                sceneItems.forEach(item => {
                    const sceneItemContainer = document.createElement('div');
                    sceneItemContainer.classList.add('scene-item-container');
                    sceneItemContainer.classList.add(`scene-color-${item.sceneIndex % 5}`); 
                    sceneItemContainer.setAttribute('data-node-id', item.nodeId); 
                    sceneItemContainer.xmlNode = item.rawNode; 
                    
                    const header = document.createElement('div');
                    header.classList.add('scene-item-header');

                    const titleBadge = document.createElement('span');
                    titleBadge.classList.add('scene-title-badge');
                    titleBadge.textContent = item.title;
                    header.appendChild(titleBadge);

                    const deleteButton = document.createElement('button');
                    deleteButton.classList.add('delete-scene-btn');
                    deleteButton.textContent = '削除';
                    deleteButton.addEventListener('click', (e) => {
                        e.stopPropagation(); 
                        deleteScene(sceneItemContainer.xmlNode); 
                    });
                    header.appendChild(deleteButton);
                    sceneItemContainer.appendChild(header);

                    const itemTextArea = document.createElement('textarea');
                    itemTextArea.value = item.text;
                    itemTextArea.classList.add('scene-text'); 
                    itemTextArea.placeholder = 'シーンの説明';
                    itemTextArea.addEventListener('input', (e) => {
                        autoResizeTextArea(e.target);
                        updateSceneContentInXml(sceneItemContainer.xmlNode, e.target.value); 
                    });
                    itemTextArea.addEventListener('change', () => { 
                        updateUIImmediate(); 
                    });
                    sceneItemContainer.appendChild(itemTextArea);
                    autoResizeTextArea(itemTextArea); 

                    sceneItemContainer.addEventListener('click', () => {
                        setActiveElement(sceneItemContainer, 'scene');
                        const firstPageElement = sceneNodeIdToFirstPageDomElementMap.get(item.nodeId); 
                        if (firstPageElement) {
                            setActiveElement(firstPageElement, 'page');
                            showColumn(2); 
                            if (window.innerWidth > 768) { 
                                setTimeout(() => {
                                    firstPageElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
                                }, 300); 
                            }
                        } else {
                            showColumn(2);
                        }
                    });
                    
                    container.appendChild(sceneItemContainer);
                    sceneNodeIdToDomElementMap.set(item.nodeId, sceneItemContainer);
                });
            }

            function updateSceneContentInXml(sceneElement, newText) {
                if (sceneElement) {
                    let sceneDescElement = sceneElement.querySelector('シーン説明');
                    if (!sceneDescElement) {
                        sceneDescElement = currentXmlDoc.createElement('シーン説明');
                        sceneElement.insertBefore(sceneDescElement, sceneElement.firstChild);
                    }
                    sceneDescElement.textContent = newText;
                    mainEditor.value = xmlSerializer.serializeToString(currentXmlDoc);
                    addToHistory(mainEditor.value);
                }
            }

            function updatePageContentInXml(pageElement, newText) {
                if (pageElement) {
                    let pageDescElement = pageElement.querySelector('ページ説明');
                    if (!pageDescElement) {
                        pageDescElement = currentXmlDoc.createElement('ページ説明');
                        // ページの最初のセリフまたは子の直前に挿入
                        const firstChild = pageElement.firstChild;
                        if (firstChild) {
                            pageElement.insertBefore(pageDescElement, firstChild);
                        } else {
                            pageElement.appendChild(pageDescElement);
                        }
                    }
                    pageDescElement.textContent = newText;
                    
                    mainEditor.value = xmlSerializer.serializeToString(currentXmlDoc);
                    addToHistory(mainEditor.value);
                }
            }

            function updateDialogueContentInXml(dialogueElement, newText) {
                if (dialogueElement) {
                    // セリフ要素のテキストコンテンツを更新
                    dialogueElement.textContent = newText; 
                    mainEditor.value = xmlSerializer.serializeToString(currentXmlDoc);
                    addToHistory(mainEditor.value);
                }
            }

            function deleteScene(sceneElement) { 
                if (!confirm('このシーンを削除してもよろしいですか？（このシーン内のページとセリフも全て削除されます）')) {
                    return;
                }
                if (sceneElement && sceneElement.parentNode) {
                    sceneElement.parentNode.removeChild(sceneElement);
                    mainEditor.value = xmlSerializer.serializeToString(currentXmlDoc);
                    addToHistory(mainEditor.value);
                    updateUIImmediate(); 
                }
            }

            function deletePage(pageElement, pageTitle) { 
                if (!confirm(`ページ ${pageTitle} を削除してもよろしいですか？（このページ内のセリフも全て削除されます）`)) {
                    return;
                }
                if (pageElement && pageElement.parentNode) {
                    pageElement.parentNode.removeChild(pageElement);
                    mainEditor.value = xmlSerializer.serializeToString(currentXmlDoc);
                    addToHistory(mainEditor.value);
                    updateUIImmediate();
                }
            }

            function setActiveElement(element, type) {
                document.querySelectorAll('.active').forEach(el => el.classList.remove('active'));

                if (element) {
                    element.classList.add('active');
                }

                if (type === 'scene') {
                    activeSceneElement = element;
                    activePageElement = null; 
                    activeDialogueElement = null;
                } else if (type === 'page') {
                    activePageElement = element;
                    activeDialogueElement = null; 
                    const parentSceneId = element.getAttribute('data-parent-scene-id');
                    if (parentSceneId) {
                        const parentSceneElement = sceneNodeIdToDomElementMap.get(parentSceneId);
                        if (parentSceneElement && parentSceneElement !== activeSceneElement) {
                            parentSceneElement.classList.add('active');
                            activeSceneElement = parentSceneElement;
                        }
                    }
                } else if (type === 'dialogue') {
                    activeDialogueElement = element;
                    const parentPageId = element.getAttribute('data-parent-page-id');
                    if (parentPageId) {
                        const parentPageElement = pageNodeIdToDomElementMap.get(parentPageId);
                        if (parentPageElement && parentPageElement !== activePageElement) {
                            parentPageElement.classList.add('active');
                            activePageElement = parentPageElement;
                        }
                        const parentSceneId = parentPageElement ? parentPageElement.getAttribute('data-parent-scene-id') : null;
                        if (parentSceneId) {
                            const parentSceneElement = sceneNodeIdToDomElementMap.get(parentSceneId);
                            if (parentSceneElement && parentSceneElement !== activeSceneElement) {
                                parentSceneElement.classList.add('active');
                                activeSceneElement = parentSceneElement;
                            }
                        }
                    }
                }
            }

            function highlightActiveElements() {
                document.querySelectorAll('.active').forEach(el => el.classList.remove('active'));

                if (activeSceneElement && sceneNodeIdToDomElementMap.has(activeSceneElement.getAttribute('data-node-id'))) {
                    sceneNodeIdToDomElementMap.get(activeSceneElement.getAttribute('data-node-id')).classList.add('active');
                }
                if (activePageElement && pageNodeIdToDomElementMap.has(activePageElement.getAttribute('data-node-id'))) {
                    pageNodeIdToDomElementMap.get(activePageElement.getAttribute('data-node-id')).classList.add('active');
                }
                if (activeDialogueElement && dialogueNodeIdToDomElementMap.has(activeDialogueElement.getAttribute('data-node-id'))) {
                    dialogueNodeIdToDomElementMap.get(activeDialogueElement.getAttribute('data-node-id')).classList.add('active');
                }
            }

            function autoResizeTextArea(textarea) {
                if (!textarea || textarea.offsetParent === null) { 
                    return; 
                }
                textarea.style.height = 'auto'; 
                // スクロール高さを取得し、少し余裕を持たせる（例: +2px）
                textarea.style.height = (textarea.scrollHeight + 2) + 'px'; 
            }

            function autoResizeAllTextareas() {
                document.querySelectorAll('textarea').forEach(autoResizeTextArea);
            }

            newBtn.addEventListener('click', clearAllEditors);

            undoBtn.addEventListener('click', undo);
            redoBtn.addEventListener('click', redo);

            mainEditor.addEventListener('input', () => {
                autoResizeTextArea(mainEditor);
                addToHistory(mainEditor.value); 
                updateUI(); 
            });
            mainEditor.addEventListener('change', () => { 
                updateUIImmediate(); 
            });

            outlineEditor.addEventListener('input', () => {
                autoResizeTextArea(outlineEditor);
            });
            outlineEditor.addEventListener('change', () => { 
                updateUIImmediate(); 
            });

            characterEditor.addEventListener('input', () => {
                autoResizeTextArea(characterEditor);
            });
            characterEditor.addEventListener('change', () => { 
                updateUIImmediate(); 
            });

            addCharacterBtn.addEventListener('click', () => {
                const newCharacterTemplate = `\n\n――――――――――\n*新しいキャラクター（名前：読み方、愛称）男女、歳\n*関係性\n*見た目、身体的特徴、服装\n*性格・裏性格\n*環境・生い立ち`;
                characterEditor.value += newCharacterTemplate;
                autoResizeTextArea(characterEditor);
                characterEditor.focus();
                characterEditor.setSelectionRange(characterEditor.value.length, characterEditor.value.length);
                updateUIImmediate(); 
            });

            addSceneBtn.addEventListener('click', () => {
                const rootElement = currentXmlDoc.querySelector('root');
                if (rootElement) {
                    const newSceneElement = currentXmlDoc.createElement('シーン');
                    const newSceneDescElement = currentXmlDoc.createElement('シーン説明');
                    newSceneDescElement.textContent = '新しいシーン';
                    newSceneElement.appendChild(newSceneDescElement);
                    
                    const newPageElement = currentXmlDoc.createElement('ページ');
                    const newPageDescElement = currentXmlDoc.createElement('ページ説明');
                    newPageDescElement.textContent = '新しいページ';
                    newPageElement.appendChild(newPageDescElement);

                    const newDialogueElement = currentXmlDoc.createElement('セリフ');
                    newDialogueElement.textContent = ''; // 新規セリフは空で開始
                    newPageElement.appendChild(newDialogueElement);
                    newSceneElement.appendChild(newPageElement);

                    rootElement.appendChild(newSceneElement);
                    
                    mainEditor.value = xmlSerializer.serializeToString(currentXmlDoc);
                    addToHistory(mainEditor.value);
                    updateUIImmediate(); 
                    mainEditor.focus();
                } else {
                    alert("XMLの<root>タグが見つかりません。構造を確認してください。");
                }
            });

            function addPageToSpecificScene(sceneElement) { 
                if (sceneElement) {
                    const newPageElement = currentXmlDoc.createElement('ページ');
                    const newPageDescElement = currentXmlDoc.createElement('ページ説明');
                    newPageDescElement.textContent = '新しいページ';
                    newPageElement.appendChild(newPageDescElement);

                    const newDialogueElement = currentXmlDoc.createElement('セリフ');
                    newDialogueElement.textContent = ''; // 新規セリフは空で開始
                    newPageElement.appendChild(newDialogueElement);

                    sceneElement.appendChild(newPageElement); 

                    mainEditor.value = xmlSerializer.serializeToString(currentXmlDoc);
                    addToHistory(mainEditor.value);
                    updateUIImmediate(); 
                    mainEditor.focus();
                } else {
                    alert('選択されたシーンがXML内で見つかりません。');
                }
            }


            toggleButtons.forEach(button => {
                button.addEventListener('click', (e) => {
                    const targetId = e.target.dataset.target;
                    const targetContent = document.getElementById(targetId);
                    setSectionVisibility(targetContent, !targetContent.classList.contains('hidden'));
                });
            });

            loadState();
            autoResizeAllTextareas(); 

            // スワイプ関連の変数 (再宣言と初期化)
            // let isSwiping = false; // 上で定義済みなので不要

            columnsWrapper.addEventListener('touchstart', (e) => {
                if (window.innerWidth <= 768) {
                    isSwiping = true; // スワイプ開始
                    touchStartX = e.touches[0].clientX;
                    // ドラッグ中はCSSトランジションを一時的に無効にする
                    columnsWrapper.style.transition = 'none'; 
                    // 現在のtranslateX値を正確に取得
                    const style = window.getComputedStyle(columnsWrapper);
                    const matrix = new DOMMatrixReadOnly(style.transform);
                    currentTranslateX = matrix.m41; // translateXのピクセル値を取得
                }
            }, { passive: false }); 

            columnsWrapper.addEventListener('touchmove', (e) => {
                // isSwiping が true の場合にのみ transform を更新
                if (window.innerWidth <= 768 && isSwiping) { 
                    e.preventDefault(); // デフォルトのスクロール動作を抑制
                    touchEndX = e.touches[0].clientX;
                    const diffPx = touchEndX - touchStartX;
                    
                    // ドラッグ量に応じて一時的にtransformを更新 (ピクセル値で加算)
                    // columnsWrapper.style.transform = `translateX(${currentTranslateX + diffPx}px)`;
                    // カラムの幅に合わせてvwで計算し直す
                    const newTransformVw = ((currentTranslateX + diffPx) / window.innerWidth) * 100;
                    columnsWrapper.style.transform = `translateX(${newTransformVw}vw)`;
                }
            }, { passive: false });

            columnsWrapper.addEventListener('touchend', (e) => { 
                if (window.innerWidth <= 768 && isSwiping) { // isSwiping が true の場合のみ処理
                    e.preventDefault(); // デフォルトのスクロール動作を抑制
                    isSwiping = false; // スワイプ終了
                    const diffPx = touchEndX - touchStartX; // ピクセル単位での差分

                    const swipeThresholdPx = window.innerWidth * 0.2; // 画面幅の20%をスワイプの閾値とする（ピクセル単位）

                    let newColumnIndex = currentColumnIndex;
                    if (diffPx < -swipeThresholdPx) { // 左スワイプ（次のカラムへ）
                        newColumnIndex = Math.min(columns.length - 1, currentColumnIndex + 1);
                    } else if (diffPx > swipeThresholdPx) { // 右スワイプ（前のカラムへ）
                        newColumnIndex = Math.max(0, currentColumnIndex - 1);
                    } else {
                        // 閾値に満たない場合、現在のカラムに戻る
                        newColumnIndex = currentColumnIndex;
                    }
                    
                    // 決定されたカラムに「カチッと」スナップさせるためにtransitionを再有効化し、showColumnを呼び出す
                    columnsWrapper.style.transition = 'transform 0.3s ease-out';
                    showColumn(newColumnIndex); 
                }
            }, { passive: false }); // touchendにもpassive: false を追加

            window.addEventListener('resize', () => {
                showColumn(currentColumnIndex); 
                autoResizeAllTextareas(); 
            });

            showColumn(currentColumnIndex); // 初期表示
        });
    </script>
</body>
</html>
